transaction T {
    input = _    // no input 
    output = 50 BTC: fun(x) . x==42
}

 transaction T1 {
    input = T: 42
    output = 50 BTC: fun(x). x != 0  // any constraint choosen by the user
}

// Alice's address
const addrA = address:mpkcxdWqT8WVeiWzMKBQosn5t8LMYL7Z3c 

transaction T2 {
    input = T1: 12
    output = 50 BTC: fun(x) . versig(addrA; x)
}

//Alice's private key    
const kA = key:cQu93pLnEtyhkEMUxiRHP2ocPXi1LRbnZZ3PLz2gp6yu11tWKUaW

transaction T3 {
    input = T2: sig(kA)
    output = 50 BTC: fun(x) . versig(addrA; x) // any condition chosen by Alice
}

//Alice's other address
const addrA2 = address:n3A4KGgZD9bW6k2pPccN4rUfX3CgYCPERb

transaction T4 {
    input = T3:sig(kA) 
    output = [
                     40 BTC: fun(x) . versig(addrA; x);
                     10 BTC: fun(x) . versig(addrA2; x)
        ]
}

//Alice's second private key
const kA2= key:cNzPt3Wad4ymq15AZ2omAmmSv5DBe99pRgsUBCQoeFPeeP57VJkm

transaction T5 {
    input = [
        T4@0: sig(kA);
        T4@1: sig(kA2)
        ]
    output = 50 BTC: fun(x) . versig(addrA; x)
}

// parametric transaction
transaction T6(k:pubkey) {
    input = _
    output = 1BTC: fun(x). versig(k;x)
}

// Alice's public key
const kApub = 
pubkey:037d33fad6067e7a76671be01f697c7667d81be0aef334385cdab2b6b8f9f484c1    

// Bob's public key
const kBpub = 
pubkey:03a5aded4cfa04cb4b49d4b19fe8fac0b58802983018cdd895a28b643e7510c1fb

transaction T7 {
    input = T6(kApub):sig(kA)
    output = 1BTC: fun(x). versig(kBpub;x)
}

transaction T8(s:signature, n:int) {
    input = T7:s 
    output = 1BTC: fun(x, m). versig(kApub;x) && m == sha256( n )
}
//transaction with empty signature
const T9 = T8(_, 4)

transaction T9_bis(n:int) {
    input = T6(kApub):sig(kA)
    output = 1BTC: fun(x, m). versig(kBpub;x) && m == sha256( n )
}


eval T1, T2, T3, T4, T5, T6(kApub), T7, T8(_,4), T9, T9_bis(4)



