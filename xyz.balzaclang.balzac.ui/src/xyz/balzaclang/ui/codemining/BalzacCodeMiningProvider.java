/*
 * Copyright 2019 Nicola Atzei
 */
/*
 * generated by Xtext 2.14.0
 */
package xyz.balzaclang.ui.codemining;

import java.util.Iterator;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.codemining.ICodeMining;
import org.eclipse.xsemantics.runtime.Result;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ui.codemining.AbstractXtextCodeMiningProvider;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.util.IAcceptor;

import com.google.inject.Inject;

import xyz.balzaclang.balzac.Constant;
import xyz.balzaclang.balzac.Type;
import xyz.balzaclang.services.BalzacGrammarAccess;
import xyz.balzaclang.xsemantics.BalzacStringRepresentation;
import xyz.balzaclang.xsemantics.BalzacTypeSystem;
import xyz.balzaclang.xsemantics.TypeSubstitutions;

@SuppressWarnings("restriction")
public class BalzacCodeMiningProvider extends AbstractXtextCodeMiningProvider {

    @Inject private BalzacGrammarAccess grammar;
    @Inject private BalzacTypeSystem typeSystem;
    @Inject private BalzacStringRepresentation strRep;

    @Override
	protected void createCodeMinings(IDocument document, XtextResource resource, CancelIndicator indicator,
		IAcceptor<? super ICodeMining> acceptor) throws BadLocationException {

	    // get all operations to open document
        List<Constant> allConstants = EcoreUtil2.eAllOfType(resource.getContents().get(0), Constant.class);

        Keyword colon = grammar.getConstantAccess().getColonKeyword_2_0();
        Keyword equalsSign = grammar.getConstantAccess().getEqualsSignKeyword_3();

        for (Constant c : allConstants) {
            // find document offset for inline annotation
            ICompositeNode node = NodeModelUtils.findActualNodeFor(c);

            boolean hasType = false;
            for (Iterator<INode> it = node.getAsTreeIterable().iterator(); it.hasNext();) {
                INode child = it.next();
                if (colon.equals(child.getGrammarElement())) {
                    hasType = true;
                }
                if (!hasType && equalsSign.equals(child.getGrammarElement())) {
                    // create line content code mining for inline annotation after grammarElement ')'
                    Result<Type> res = typeSystem.typeExpression(new TypeSubstitutions(), c);
                    if (!res.failed()) {
                        String annotationText = ": " + strRep.stringRep(res.getFirst())+" ";
                        acceptor.accept(createNewLineContentCodeMining(child.getTotalOffset(), annotationText));
                    }
                }
            }
        }

	    // TODO: implement me
		// use acceptor.accept(super.createNewLineHeaderCodeMining(...)) to add a new code mining to the final list

		// example:
		// acceptor.accept(createNewLineHeaderCodeMining(1, document, "Header annotation"));
	}
}
