/*
 * Copyright 2017 Nicola Atzei
 */

import it.unica.tcs.bitcoinTM.AbsoluteTime
import it.unica.tcs.bitcoinTM.AddressType
import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Compile
import it.unica.tcs.bitcoinTM.Constant
import it.unica.tcs.bitcoinTM.DateLiteral
import it.unica.tcs.bitcoinTM.Div
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Hash160
import it.unica.tcs.bitcoinTM.Hash160Literal
import it.unica.tcs.bitcoinTM.Hash160Type
import it.unica.tcs.bitcoinTM.Hash256
import it.unica.tcs.bitcoinTM.Hash256Literal
import it.unica.tcs.bitcoinTM.Hash256Type
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.KeyLiteral
import it.unica.tcs.bitcoinTM.KeyType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Output
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.PermittedType
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Reference
import it.unica.tcs.bitcoinTM.Ripemd160
import it.unica.tcs.bitcoinTM.Ripemd160Literal
import it.unica.tcs.bitcoinTM.Ripemd160Type
import it.unica.tcs.bitcoinTM.Sha256
import it.unica.tcs.bitcoinTM.Sha256Literal
import it.unica.tcs.bitcoinTM.Sha256Type
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureLiteral
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Times
import it.unica.tcs.bitcoinTM.Transaction
import it.unica.tcs.bitcoinTM.TransactionLiteral
import it.unica.tcs.bitcoinTM.TransactionType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.TypeVariable
import it.unica.tcs.bitcoinTM.Typeable
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import org.bitcoinj.core.Address
import org.bitcoinj.core.DumpedPrivateKey
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil
import it.unica.tcs.bitcoinTM.RelativeTime

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

inject LambdaUtils lambdaUtils

auxiliary {
        
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    
    unify(TypeSubstitutions substitutions, Type left, Type right) : Type
        error "Cannot unify " + stringRep(left) + " with " + stringRep(right)
    
    failIfTypeVariable(Type type, EObject obj)
    failIfNotPermitted(Type type, EObject obj)
}

judgments {

	typeExpression |- TypeSubstitutions substitutions |> Typeable exp : output Type
		error "Cannot type " + stringRep(exp)
		source exp
}

/*
 * auxiliary functions
 */

auxiliary failIfTypeVariable(Type type, EObject obj) {
	if (type instanceof TypeVariable) {
		fail
		error "Cannot infer the type"
		source obj
	}
}

auxiliary failIfNotPermitted(Type type, EObject obj) {
	if (!(type instanceof PermittedType)) {
		fail
		error "Basic type expected: int, string, bool, hash160, hash256, ripemd160, sha256, transaction, signature, key, address, pubkey"
		source obj
	}
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(TypeSubstitutions substitutions, Type t1, Type t2) {
    // if we get here we cannot unify the two types
    fail
	error "Cannot unify type "+t1+" with type "+t2
	null
} 

auxiliary unify(TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash160Type t1, Hash160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash256Type t1, Hash256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Ripemd160Type t1, Ripemd160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Sha256Type t1, Sha256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, KeyType t1, KeyType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, AddressType t1, AddressType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, TransactionType t1, TransactionType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable typeVar, PermittedType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(TypeSubstitutions substitutions, PermittedType basicType, TypeVariable typeVar) {
    unify(substitutions, typeVar, basicType)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}

// hash256 is a sha256
auxiliary unify(TypeSubstitutions substitutions, Hash256Type t1, Sha256Type t2) {
    EcoreUtil::copy(t2)		
}

// hash256 is a sha256
auxiliary unify(TypeSubstitutions substitutions, Sha256Type t1, Hash256Type t2) {
    EcoreUtil::copy(t1)
}

// hash160 is a sha256
auxiliary unify(TypeSubstitutions substitutions, Hash160Type t1, Ripemd160Type t2) {
    EcoreUtil::copy(t2)
}

// hash160 is a sha256
auxiliary unify(TypeSubstitutions substitutions, Ripemd160Type t1, Hash160Type t2) {
    EcoreUtil::copy(t1)
}

// key is subtype of address: you can derive an address from its private part
auxiliary unify(TypeSubstitutions substitutions, KeyType t1, AddressType t2) {
    EcoreUtil::copy(t2)
}



/*
 * Type system rules
 */

rule Parameter
	G |- TypeSubstitutions substitutions |> Parameter p : Type type
from {
	{
		p.type !== null
		type = EcoreUtil.copy(p.type)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
	G.add(p, type)
}

rule Constant
	G |- TypeSubstitutions substitutions |> Constant c : Type type
from {
	{
		c.type !== null
		type = EcoreUtil.copy(c.type)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
	
	G |- substitutions |> c.exp : var Type expType
	type = unify(substitutions, expType, type)
	
	failIfTypeVariable(type, c)
	c.type = type as PermittedType	// store the type in the AST
}

rule Reference
	G |- TypeSubstitutions substitutions |> Reference varRef : Type type
from {
	
	if (varRef.ref instanceof Constant) {
		val const = varRef.ref as Constant
		G |- substitutions |> const : type
	}
	else if (varRef.ref instanceof Parameter) {
		val param = varRef.ref as Parameter
		G |- substitutions |> param : type
	}
	else if (varRef.ref instanceof Transaction) {
		val tx = varRef.ref as Transaction
		
		G |- substitutions |> tx : type
		type = typesubstitution(substitutions, type)
		unify(substitutions, type, BitcoinTMFactory::eINSTANCE.createTransactionType)

		if (varRef.actualParams.size != tx.params.size) {
			fail 
				error "Invalid number of actual parameters."
				source varRef
		}
		
		// check the actual parameters type match the formal ones
		for (var i=0; i<varRef.actualParams.size; i++) {
			var actualParam = varRef.actualParams.get(i)
			var formalParam = tx.params.get(i)
			
			// get formal parameter type
			var formalParamType = env(G, formalParam, Type)
			// apply eventual substitutions to get the basic type
			formalParamType = typesubstitution(substitutions, formalParamType)
			// ensure it's basic
			failIfTypeVariable(formalParamType, formalParam)
			
			// all the actual parameters are well typed
			G |- substitutions |> actualParam : var Type actualParamType
			// apply eventual substitutions
			actualParamType = typesubstitution(substitutions, actualParamType)
			
			// the actual param type must be unifiable with the formal param type
			unify(substitutions, actualParamType, formalParamType)
			
			// store the type in the AST
			formalParam.type = formalParamType as PermittedType
		}
		
	}
}

/*
 * - all the inputs are well typed
 * - all the outputs are well typed
 */
rule Transaction
	G |- TypeSubstitutions substitutions |> Transaction body : BitcoinTMFactory::eINSTANCE.createTransactionType
from {
	
	for (in : body.inputs) {
		G |- substitutions |> in : var Type t1	// all inputs are well typed
	}
	
	for (out : body.outputs) {
		G |- substitutions |> out : var Type t2	// all outputs are well typed
	}
}


/**
 * An input is well typed if:
 * - the body of the redeemed transaction is well typed
 * - all the expressions are well typed and the type is basic (not generic)
 * - if the redeemed tx has free variables, check that the actual types corresponds to the formal ones 
 * - if the redeemed tx is user defined, all the expression type corresponds to the expected type of the parameter
 */
rule Input
	G |- TypeSubstitutions substitutions |> Input input : BitcoinTMFactory::eINSTANCE.createVoidType
from {
	
	if (!input.isPlaceholder) {
		
		val txType = BitcoinTMFactory::eINSTANCE.createTransactionType
		
		// the body of the redeemed transaction is well typed
		G |- substitutions |> input.txRef : var Type t1		// eventual tx parameters have type BasicType
		t1 = typesubstitution(substitutions, t1)
		unify(substitutions, t1, txType)
		
		val inputTxRef = input.txRef

		if (inputTxRef instanceof Reference) {
			
			val tx = inputTxRef.ref as Transaction
			
			
			// check the actual parameters type match the formal ones (Script)
			var outputIndex = input.outpoint
			var outputScript = tx.outputs.get(new Long(outputIndex).intValue).script

			if (input.exps.size != outputScript.params.size) {
				fail 
					error "Invalid number of actual parameters."
					source input
			}

			for (var i=0; i<input.exps.size; i++) {
				var inputExp = input.exps.get(i)
				var outputParam = outputScript.params.get(i)
				
				// get formal parameter type
				var formalParamType = env(G, outputParam, Type)
				// apply eventual substitutions to get the basic type
				formalParamType = typesubstitution(substitutions, formalParamType)
				// ensure it's basic
				failIfTypeVariable(formalParamType, outputParam)
				
				// all the actual parameters are well typed
				G |- substitutions |> inputExp : var Type actualParamType
				// apply eventual substitutions
				actualParamType = typesubstitution(substitutions, actualParamType)
				
				// the actual param type must be unifiable with the formal param type
				unify(substitutions, actualParamType, formalParamType)
				
				// store the type in the AST
				outputParam.type = formalParamType as PermittedType
			}
		}
		else {
			// all the input expressions are well typed and the type is basic
			for (var i=0; i<input.exps.size; i++) {
				var exp = input.exps.get(i)
				G |- substitutions |> exp : var Type texp
				texp = typesubstitution(substitutions, texp)
				failIfTypeVariable(texp, exp)
			}
		} 
	}
}

/**
 * An Output is well typed if:
 * - all the scripts parameters are well typed and the type is basic (not generic)
 * - all the scripts expressions are well typed
 */
rule Output
	G |- TypeSubstitutions substitutions |> Output _output : BitcoinTMFactory::eINSTANCE.createVoidType
from {
	var satoshis = _output.value.exp
	G |- new TypeSubstitutions() |> satoshis : var IntType intType
	
	var script = _output.script
	for (p : script.params) {
		G |- substitutions |> p : var Type type
	}


	G |- substitutions |> script.exp : var Type scriptType
	scriptType = typesubstitution(substitutions, scriptType)	
	{
		unify(substitutions, scriptType, BitcoinTMFactory::eINSTANCE.createBooleanType)
	} or {
		unify(substitutions, scriptType, BitcoinTMFactory::eINSTANCE.createStringType)
	}
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : script.params) {
		var ptype = env(G, p, Type)
		ptype = typesubstitution(substitutions, ptype)
		failIfNotPermitted(ptype, p)
		p.type = ptype as PermittedType
	}
}

rule AbsoluteTime
	G |- TypeSubstitutions substitutions |> AbsoluteTime tlock : BitcoinTMFactory::eINSTANCE.createVoidType
from {
	G |- substitutions |> tlock.value : var Type type
	type = typesubstitution(substitutions, type)
	unify(substitutions, type, BitcoinTMFactory::eINSTANCE.createIntType)
}

rule RelativeTime
	G |- TypeSubstitutions substitutions |> RelativeTime tlock : BitcoinTMFactory::eINSTANCE.createVoidType
from {
	G |- substitutions |> tlock.value : var Type type
	type = typesubstitution(substitutions, type)
	unify(substitutions, type, BitcoinTMFactory::eINSTANCE.createIntType)
	
	if (tlock.tx !== null) {
		G |- substitutions |> tlock.tx : var Type txtype
		txtype = typesubstitution(substitutions, txtype)
		unify(substitutions, txtype, BitcoinTMFactory::eINSTANCE.createTransactionType)
	}
}	

/*
 * Expressions type system
 */
axiom NumeralLiteral
	G |- TypeSubstitutions substitutions |> NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- TypeSubstitutions substitutions |> StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Hash160Literal
	G |- TypeSubstitutions substitutions |> Hash160Literal h : BitcoinTMFactory::eINSTANCE.createHash160Type

axiom Hash256Literal
	G |- TypeSubstitutions substitutions |> Hash256Literal h : BitcoinTMFactory::eINSTANCE.createHash256Type

axiom Ripemd160Literal
	G |- TypeSubstitutions substitutions |> Ripemd160Literal h : BitcoinTMFactory::eINSTANCE.createRipemd160Type

axiom Sha256Literal
	G |- TypeSubstitutions substitutions |> Sha256Literal h : BitcoinTMFactory::eINSTANCE.createSha256Type

axiom TransactionLiteral
	G |- TypeSubstitutions substitutions |> TransactionLiteral tx : BitcoinTMFactory::eINSTANCE.createTransactionType

axiom SignatureLiteral
	G |- TypeSubstitutions substitutions |> SignatureLiteral s : BitcoinTMFactory::eINSTANCE.createSignatureType

axiom DateLiteral
	G |- TypeSubstitutions substitutions |> DateLiteral d : BitcoinTMFactory::eINSTANCE.createIntType

rule KeyLiteral
	G |- TypeSubstitutions substitutions |> KeyLiteral key : Type res
from {
	{
		DumpedPrivateKey.fromBase58(null, key.value);
		res = BitcoinTMFactory::eINSTANCE.createKeyType
	} or {
		Address.fromBase58(null, key.value);
		res = BitcoinTMFactory::eINSTANCE.createAddressType	
	}
}


rule Times
	G |- TypeSubstitutions substitutions |> Times minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Div
	G |- TypeSubstitutions substitutions |> Div minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Minus
	G |- TypeSubstitutions substitutions |> Minus minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> Plus plus : Type type
from {
    G |- substitutions |> plus.left : var Type leftType
    G |- substitutions |> plus.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
    {
       	type = BitcoinTMFactory::eINSTANCE.createIntType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
	}
    or
    {
    	type = BitcoinTMFactory::eINSTANCE.createStringType
		// the terms type must be unifiable with string type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
    }
}

rule Comparison
	G |- TypeSubstitutions substitutions |> Comparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Equals
	G |- TypeSubstitutions substitutions |> Equals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// equals between elements of the same type
	unify(substitutions, leftType, rightType)
}

rule BooleanNegation
	G |- TypeSubstitutions substitutions |> BooleanNegation negation : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> negation.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, boolType)
}

rule Or
	G |- TypeSubstitutions substitutions |> OrExpression orExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> orExp.left : var Type leftType
	G |- substitutions |> orExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule And
	G |- TypeSubstitutions substitutions |> AndExpression andExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> andExp.left : var Type leftType
	G |- substitutions |> andExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule ArithmeticSigned
	G |- TypeSubstitutions substitutions |> ArithmeticSigned signed : IntType intType
from {
	intType = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> signed.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, intType)
}

rule IfThenElse
	G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
	var boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> stmt.^if: var Type tIf
	G |- substitutions |> stmt.then: var Type tThen
	
	tIf = typesubstitution(substitutions, tIf)
	tThen = typesubstitution(substitutions, tThen)
	
	unify(substitutions, tIf, boolType)

	G |- substitutions |> stmt.^else: var Type tElse
	tElse = typesubstitution(substitutions, tElse)
	unify(substitutions, tThen, tElse)
	
	type=tThen
}

rule VerSig
	G |- TypeSubstitutions substitutions |> Versig versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var addrType = BitcoinTMFactory::eINSTANCE.createAddressType
	
	for (k : versig.pubkeys) {
		G |- substitutions |> k : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, addrType)
	}

	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type ts
		ts = typesubstitution(substitutions, ts)
		unify(substitutions, ts, sigType)
	}
}

rule Signature
	G |- TypeSubstitutions substitutions |> Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType
from {
	var keyType = BitcoinTMFactory::eINSTANCE.createKeyType

	G |- substitutions |> s.privkey : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, keyType)
	
	if (s.tx !== null) {
		var txType = BitcoinTMFactory::eINSTANCE.createTransactionType
	
		G |- substitutions |> s.tx : var Type t1
		t1 = typesubstitution(substitutions, t1)
		unify(substitutions, t1, txType)		
	}
}

rule Hash160
	G |- TypeSubstitutions substitutions |> Hash160 hash: BitcoinTMFactory::eINSTANCE.createHash160Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	failIfNotPermitted(t, hash)
}

rule Hash256
	G |- TypeSubstitutions substitutions |> Hash256 hash: BitcoinTMFactory::eINSTANCE.createHash256Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	failIfNotPermitted(t, hash)
}

rule Ripemd160
	G |- TypeSubstitutions substitutions |> Ripemd160 hash: BitcoinTMFactory::eINSTANCE.createRipemd160Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	failIfNotPermitted(t, hash)
}

rule Sha256
	G |- TypeSubstitutions substitutions |> Sha256 hash: BitcoinTMFactory::eINSTANCE.createSha256Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	failIfNotPermitted(t, hash)
}

rule Min
	G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> min.left: var Type tleft
	G |- substitutions |> min.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Max
	G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> max.left: var Type tleft
	G |- substitutions |> max.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Between
	G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> between.value: var Type tValue
	G |- substitutions |> between.left: var Type tLeft
	G |- substitutions |> between.right: var Type tRight
	
	tValue = typesubstitution(substitutions, tValue)
	tLeft = typesubstitution(substitutions, tLeft)
	tRight = typesubstitution(substitutions, tRight)
	
	unify(substitutions, tValue, t)
	unify(substitutions, tLeft, t)
	unify(substitutions, tRight, t)
}

rule Size
	G |- TypeSubstitutions substitutions |> Size size: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> size.value: var Type t
	
	t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
	G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
	G |- substitutions |> after.timelock: var Type t
	
	G |- substitutions |> after.continuation: texpr
	texpr = typesubstitution(substitutions, texpr)
}


rule Compile
	G |- TypeSubstitutions substitutions |> Compile compile: BitcoinTMFactory::eINSTANCE.createVoidType
from {
	for (e : compile.txs) {		
		G |- substitutions |> e: var Type texpr
		texpr = typesubstitution(substitutions, texpr)
		failIfNotPermitted(texpr, e)
	}
}

/*
 * 
 * rule invocations
 * 
 */

checkrule CheckConstants for
    Constant stmt
from {
	lambdaUtils.resetCounter
    empty |- new TypeSubstitutions |> stmt: var Type t
}

checkrule CheckTransactions for
    Transaction stmt
from {
	lambdaUtils.resetCounter
    empty |- new TypeSubstitutions |> stmt: var Type t
}

checkrule CheckCompile for
    Compile stmt
from {
	lambdaUtils.resetCounter
    empty |- new TypeSubstitutions |> stmt: var Type t
}
