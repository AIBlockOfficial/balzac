/*
 * Copyright 2017 Nicola Atzei
 */

import it.unica.tcs.balzac.AbsoluteTime
import it.unica.tcs.balzac.AddressLiteral
import it.unica.tcs.balzac.AddressType
import it.unica.tcs.balzac.AfterTimeLock
import it.unica.tcs.balzac.AndExpression
import it.unica.tcs.balzac.ArithmeticSigned
import it.unica.tcs.balzac.BalzacFactory
import it.unica.tcs.balzac.BasicType
import it.unica.tcs.balzac.Between
import it.unica.tcs.balzac.BooleanLiteral
import it.unica.tcs.balzac.BooleanNegation
import it.unica.tcs.balzac.BooleanType
import it.unica.tcs.balzac.Comparison
import it.unica.tcs.balzac.Constant
import it.unica.tcs.balzac.DateLiteral
import it.unica.tcs.balzac.Div
import it.unica.tcs.balzac.Equals
import it.unica.tcs.balzac.Eval
import it.unica.tcs.balzac.Hash160
import it.unica.tcs.balzac.Hash256
import it.unica.tcs.balzac.HashLiteral
import it.unica.tcs.balzac.HashType
import it.unica.tcs.balzac.HashableType
import it.unica.tcs.balzac.IfThenElse
import it.unica.tcs.balzac.Input
import it.unica.tcs.balzac.IntType
import it.unica.tcs.balzac.KeyLiteral
import it.unica.tcs.balzac.KeyType
import it.unica.tcs.balzac.Max
import it.unica.tcs.balzac.Min
import it.unica.tcs.balzac.Minus
import it.unica.tcs.balzac.Model
import it.unica.tcs.balzac.NumberLiteral
import it.unica.tcs.balzac.OrExpression
import it.unica.tcs.balzac.Output
import it.unica.tcs.balzac.Parameter
import it.unica.tcs.balzac.Plus
import it.unica.tcs.balzac.PubKeyLiteral
import it.unica.tcs.balzac.PubkeyType
import it.unica.tcs.balzac.Reference
import it.unica.tcs.balzac.RelativeTime
import it.unica.tcs.balzac.Ripemd160
import it.unica.tcs.balzac.Script
import it.unica.tcs.balzac.Sha1
import it.unica.tcs.balzac.Sha256
import it.unica.tcs.balzac.Signature
import it.unica.tcs.balzac.SignatureLiteral
import it.unica.tcs.balzac.SignaturePlaceholder
import it.unica.tcs.balzac.SignatureType
import it.unica.tcs.balzac.Size
import it.unica.tcs.balzac.StringLiteral
import it.unica.tcs.balzac.StringType
import it.unica.tcs.balzac.This
import it.unica.tcs.balzac.Times
import it.unica.tcs.balzac.Transaction
import it.unica.tcs.balzac.TransactionHexLiteral
import it.unica.tcs.balzac.TransactionIDLiteral
import it.unica.tcs.balzac.TransactionInputOperation
import it.unica.tcs.balzac.TransactionOutputOperation
import it.unica.tcs.balzac.TransactionType
import it.unica.tcs.balzac.Type
import it.unica.tcs.balzac.TypeVariable
import it.unica.tcs.balzac.Typeable
import it.unica.tcs.balzac.Versig
import it.unica.tcs.utils.ASTUtils
import it.unica.tcs.validation.AbstractBalzacValidator
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xsemantics.runtime.RuleEnvironment
import org.eclipse.xtext.EcoreUtil2

system it.unica.tcs.xsemantics.BalzacTypeSystem

validatorExtends AbstractBalzacValidator

inject LambdaUtils lambdaUtils
inject extension ASTUtils astUtils

auxiliary {
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    unify(EObject obj, TypeSubstitutions substitutions, Type left, Type right) : Type
    failIfTypeVariable(Type type, EObject obj)
    failIfNotBasic(Type type, EObject obj)
}

judgments {
    typeExpression |- TypeSubstitutions substitutions |> Typeable exp : output Type
        error "Cannot type " + stringRep(exp)
        source exp
}

/*
 * auxiliary functions
 */

auxiliary failIfTypeVariable(Type type, EObject obj) {
    if (type instanceof TypeVariable) {
        fail
        error "Cannot infer the type"
        source obj
    }
}

auxiliary failIfNotBasic(Type type, EObject obj) {
    if (!(type instanceof BasicType)) {
        fail
        error "Basic type expected: int, string, bool, hash160, hash256, ripemd160, sha256, transaction, signature, key, address, pubkey"
        source obj
    }
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, Type actual, Type expected) {
    // if we get here we cannot unify the two types
    fail
    error 'Invalid type '+stringRep(actual)+", expected type "+stringRep(expected)
    source obj
    null
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, HashType t1, HashType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, KeyType t1, KeyType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, AddressType t1, AddressType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, TransactionType t1, TransactionType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, PubkeyType t1, PubkeyType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, TypeVariable typeVar, BasicType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, BasicType basicType, TypeVariable typeVar) {
    unify(obj, substitutions, typeVar, basicType)
}

auxiliary unify(EObject obj, TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}

// key is subtype of address: you can derive an address from its private part
auxiliary unify(EObject obj, TypeSubstitutions substitutions, KeyType t1, AddressType t2) {
    EcoreUtil::copy(t2)
}

// key is subtype of a pubkey: you can derive the public part from its private part
auxiliary unify(EObject obj, TypeSubstitutions substitutions, KeyType t1, PubkeyType t2) {
    EcoreUtil::copy(t2)
}

// pubkey is subtype of an address: you can derive the address from its pubkey
auxiliary unify(EObject obj, TypeSubstitutions substitutions, PubkeyType t1, AddressType t2) {
    EcoreUtil::copy(t2)
}



/*
 * Type system rules
 */
axiom SignaturePlaceholder
    G |- TypeSubstitutions substitutions |> SignaturePlaceholder p : BalzacFactory::eINSTANCE.createSignatureType 

rule Parameter
    G |- TypeSubstitutions substitutions |> Parameter p : Type type
from {
    {
        p.type !== null
        type = EcoreUtil.copy(p.type)
    }
    or {
        type = lambdaUtils.createFreshTypeVariable
    }
    G.add(p, type)
}

// a constant always has a basic type (int, string, ...)
rule Constant
    G |- TypeSubstitutions substitutions |> Constant c : Type type
from {
    {
        c.type !== null
        type = EcoreUtil.copy(c.type)
    }
    or {
        type = lambdaUtils.createFreshTypeVariable
    }
    
    substitutions.addVisited(c)
    G |- substitutions |> (c.exp as Typeable) : var Type expType
    type = unify(c.exp, substitutions, expType, type)
    substitutions.removeVisited(c)

    failIfNotBasic(type, c)
    c.type = EcoreUtil::copy(type as BasicType)     // store the type in the AST
    G.add(c, type)                                  // store the type in env to avoid recomputation
}

rule This
    G |- TypeSubstitutions substitutions |> This thiz : BalzacFactory::eINSTANCE.createTransactionType
from {
    val tx = EcoreUtil2.getContainerOfType(thiz, Transaction)

    // check if tx is already visited
    if (substitutions.isAlreadyVisited(tx)) {
        fail
            error "Found cyclic dependency"
            source thiz
    }
}

rule Reference
    G |- TypeSubstitutions substitutions |> Reference varRef : Type type
from {
    if (substitutions.isAlreadyVisited(varRef.ref)) {
        fail
            error "Found cyclic dependency"
            source varRef
    }

    if (varRef.ref instanceof Constant) {
        if (!varRef.actualParams.^empty) {
            fail
                error "Constant reference cannot have actual parameters"
                source varRef
        }
        val const = varRef.ref as Constant
        type = G.get(const) as BasicType    // avoid recomputation if possible
        if (type === null) {
            G |- substitutions |> const : type
        }
    }
    else if (varRef.ref instanceof Parameter) {
        if (!varRef.actualParams.^empty) {
            fail
                error "Parameter reference cannot have actual parameters"
                source varRef
        }
        val param = varRef.ref as Parameter
        G |- substitutions |> param : type
    }
    else if (varRef.ref instanceof Transaction) {
        val tx = varRef.ref as Transaction
        if (varRef.actualParams.size != tx.params.size) {
            fail
                error "Invalid number of actual parameters."
                source varRef
        }

        G |- substitutions |> tx : type
        type = typesubstitution(substitutions, type)
        unify(tx, substitutions, type, BalzacFactory::eINSTANCE.createTransactionType)

        // check the actual parameters type match the formal ones
        for (var i=0; i<varRef.actualParams.size; i++) {
            var actualParam = varRef.actualParams.get(i)
            var formalParam = tx.params.get(i)

            // get formal parameter type
            var formalParamType = env(G, formalParam, Type)
            // apply eventual substitutions to get the basic type
            formalParamType = typesubstitution(substitutions, formalParamType)
            // ensure it's basic
            failIfTypeVariable(formalParamType, formalParam)

            // all the actual parameters are well typed
            G |- substitutions |> actualParam : var Type actualParamType
            // apply eventual substitutions
            actualParamType = typesubstitution(substitutions, actualParamType)

            // the actual param type must be unifiable with the formal param type
            unify(actualParam, substitutions, actualParamType, formalParamType)
        }
    }
    else {
        fail
            error "Unexpected class "+varRef.ref
            source varRef
    }
}

/*
 * - all the inputs are well typed
 * - all the outputs are well typed
 */
rule Transaction
    G |- TypeSubstitutions substitutions |> Transaction tx : Type txType
from {
    txType = BalzacFactory::eINSTANCE.createTransactionType
    substitutions.addVisited(tx)

    for (p : tx.params) {
        G |- substitutions |> p : var Type t    // type the parameters, possibly TypeVariable
    }

    for (in : tx.inputs) {
        G |- substitutions |> in : var Type t1  // all inputs are well typed
    }

    for (out : tx.outputs) {
        G |- substitutions |> out : var Type t2 // all outputs are well typed
    }

    substitutions.removeVisited(tx)

    // after typing the parameters, all should have a basic type (generic types are not allowed)
    for (p : tx.params) {
        var ptype = env(G, p, Type)
        ptype = typesubstitution(substitutions, ptype)
        failIfTypeVariable(ptype, p)
        // store the type in the AST
        p.type = EcoreUtil::copy(ptype as BasicType)
    }
}

/**
 * An input is well typed if:
 * - the body of the redeemed transaction is well typed
 * - all the expressions are well typed and the type is basic (not generic)
 * - if the redeemed tx has free variables, check that the actual types corresponds to the formal ones
 * - if the redeemed tx is user defined, all the expression type corresponds to the expected type of the parameter
 */
rule Input
    G |- TypeSubstitutions substitutions |> Input input : BalzacFactory::eINSTANCE.createVoidType
from {
    if (!input.isPlaceholder) {

        val txType = BalzacFactory::eINSTANCE.createTransactionType

        // the body of the redeemed transaction is well typed
        G |- substitutions |> input.txRef : var Type t1     // eventual tx parameters have type BasicType
        t1 = typesubstitution(substitutions, t1)
        unify(input.txRef, substitutions, t1, txType)

        val inputTxRef = input.txRef

        if (inputTxRef instanceof Reference
            && (inputTxRef as Reference).ref instanceof Transaction
        ) {
            val tx = (inputTxRef as Reference).ref as Transaction

            // check the actual parameters type match the formal ones (Script)
            var outputIndex = input.outpoint
            var outputScript = tx.outputs.get(new Long(outputIndex).intValue).script

            if (input.exps.size != (outputScript as Script).params.size) {
                fail
                    error "Invalid number of actual parameters."
                    source input
            }

            for (var i=0; i<input.exps.size; i++) {
                var inputExp = input.exps.get(i)
                var outputParam = (outputScript as Script).params.get(i)

                // get formal parameter type
                var formalParamType = env(G, outputParam, Type)
                // apply eventual substitutions to get the basic type
                formalParamType = typesubstitution(substitutions, formalParamType)
                // ensure it's basic
                failIfTypeVariable(formalParamType, outputParam)

                // all the actual parameters are well typed
                G |- substitutions |> inputExp : var Type actualParamType
                // apply eventual substitutions
                actualParamType = typesubstitution(substitutions, actualParamType)

                // the actual param type must be unifiable with the formal param type
                unify(inputExp, substitutions, actualParamType, formalParamType)
            }
        }
        else {
            // all the input expressions are well typed and the type is basic
            for (var i=0; i<input.exps.size; i++) {
                var exp = input.exps.get(i)
                G |- substitutions |> exp : var Type texp
                texp = typesubstitution(substitutions, texp)
                failIfTypeVariable(texp, exp)
            }
        }
    }
}

/**
 * An Output is well typed if:
 * - all the scripts parameters are well typed and the type is basic (not generic)
 * - all the scripts expressions are well typed
 */
rule Output
    G |- TypeSubstitutions substitutions |> Output _output : BalzacFactory::eINSTANCE.createVoidType
from {
    var satoshis = _output.value.exp
    G |- substitutions |> satoshis : var Type valType
    valType = typesubstitution(substitutions, valType)
    unify(satoshis, substitutions, valType, BalzacFactory::eINSTANCE.createIntType)

    var script = _output.script as Script
    for (p : script.params) {
        G |- substitutions |> p : var Type type
    }

    G |- substitutions |> script.exp : var Type expType
    expType = typesubstitution(substitutions, expType)

    if (script.params.size == 0) {
        {
            unify(script.exp, substitutions, expType, BalzacFactory::eINSTANCE.createBooleanType)
        } or {
            unify(script.exp, substitutions, expType, BalzacFactory::eINSTANCE.createStringType)
        } or {
            fail
            error "expected type boolean or string"
            source script.exp
        }     
    }
    else {
        unify(script.exp, substitutions, expType, BalzacFactory::eINSTANCE.createBooleanType)
    }
    
    // all the parameters should have a basic type (generic types are not allowed)
    for (p : script.params) {
        var ptype = env(G, p, Type)
        ptype = typesubstitution(substitutions, ptype)
        failIfNotBasic(ptype, p)
        // store the type in the AST
        p.type = EcoreUtil::copy(ptype as BasicType)
    }
}

rule AbsoluteTime
    G |- TypeSubstitutions substitutions |> AbsoluteTime tlock : BalzacFactory::eINSTANCE.createVoidType
from {
    G |- substitutions |> tlock.value : var Type type
    type = typesubstitution(substitutions, type)
    unify(tlock.value, substitutions, type, BalzacFactory::eINSTANCE.createIntType)
}

rule RelativeTime
    G |- TypeSubstitutions substitutions |> RelativeTime tlock : BalzacFactory::eINSTANCE.createVoidType
from {
    if (tlock.isBlock) {
        G |- substitutions |> tlock.value : var Type type
        type = typesubstitution(substitutions, type)
        unify(tlock.value, substitutions, type, BalzacFactory::eINSTANCE.createIntType)
    }

    if (tlock.tx !== null) {
        G |- substitutions |> tlock.tx : var Type txtype
        txtype = typesubstitution(substitutions, txtype)
        unify(tlock.value, substitutions, txtype, BalzacFactory::eINSTANCE.createTransactionType)
    }
}

/*
 * Expressions type system
 */
axiom NumeralLiteral
    G |- TypeSubstitutions substitutions |> NumberLiteral num : BalzacFactory::eINSTANCE.createIntType

axiom BooleanLiteral
    G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BalzacFactory::eINSTANCE.createBooleanType

axiom StringLiteral
    G |- TypeSubstitutions substitutions |> StringLiteral str : BalzacFactory::eINSTANCE.createStringType

axiom HashLiteral
    G |- TypeSubstitutions substitutions |> HashLiteral h : BalzacFactory::eINSTANCE.createHashType

axiom TransactionHexLiteral
    G |- TypeSubstitutions substitutions |> TransactionHexLiteral tx : BalzacFactory::eINSTANCE.createTransactionType

axiom TransactionIDLiteral
    G |- TypeSubstitutions substitutions |> TransactionIDLiteral tx : BalzacFactory::eINSTANCE.createTransactionType

axiom SignatureLiteral
    G |- TypeSubstitutions substitutions |> SignatureLiteral s : BalzacFactory::eINSTANCE.createSignatureType

axiom DateLiteral
    G |- TypeSubstitutions substitutions |> DateLiteral d : BalzacFactory::eINSTANCE.createIntType

axiom KeyLiteral
    G |- TypeSubstitutions substitutions |> KeyLiteral key : BalzacFactory::eINSTANCE.createKeyType

axiom AddressLiteral
    G |- TypeSubstitutions substitutions |> AddressLiteral addr : BalzacFactory::eINSTANCE.createAddressType

axiom PubkeyLiteral
    G |- TypeSubstitutions substitutions |> PubKeyLiteral pk : BalzacFactory::eINSTANCE.createPubkeyType


rule Times
    G |- TypeSubstitutions substitutions |> Times op : IntType t
from {
    t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> op.left: var Type leftType
    G |- substitutions |> op.right: var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    // the terms type must be unifiable with int type
    unify(op.left, substitutions, leftType, t)
    unify(op.right, substitutions, rightType, t)
}

rule Div
    G |- TypeSubstitutions substitutions |> Div op : IntType t
from {
    t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> op.left: var Type leftType
    G |- substitutions |> op.right: var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    // the terms type must be unifiable with int type
    unify(op.left, substitutions, leftType, t)
    unify(op.right, substitutions, rightType, t)
}

rule Minus
    G |- TypeSubstitutions substitutions |> Minus op : IntType t
from {
    t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> op.left: var Type leftType
    G |- substitutions |> op.right: var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    // the terms type must be unifiable with int type
    unify(op.left, substitutions, leftType, t)
    unify(op.right, substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> Plus op : Type type
from {
    G |- substitutions |> op.left : var Type leftType
    G |- substitutions |> op.right : var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    {
        type = BalzacFactory::eINSTANCE.createIntType
        // the terms type must be unifiable with int type
        unify(op.left, substitutions, leftType, type)
    }
    or
    {
        type = BalzacFactory::eINSTANCE.createStringType
        // the terms type must be unifiable with string type
        unify(op.left, substitutions, leftType, type)
    }

    unify(op.right, substitutions, rightType, type)
}

rule Comparison
    G |- TypeSubstitutions substitutions |> Comparison op : BalzacFactory::eINSTANCE.createBooleanType
from {
    var t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> op.left : var Type leftType
    G |- substitutions |> op.right : var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    unify(op.left, substitutions, leftType, t)
    unify(op.right, substitutions, rightType, t)
}

rule Equals
    G |- TypeSubstitutions substitutions |> Equals op : BalzacFactory::eINSTANCE.createBooleanType
from {
    G |- substitutions |> op.left : var Type leftType
    G |- substitutions |> op.right : var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    // equals between elements of the same type
    unify(op.right, substitutions, rightType, leftType)
}

rule BooleanNegation
    G |- TypeSubstitutions substitutions |> BooleanNegation negation : BooleanType boolType
from {
    boolType = BalzacFactory::eINSTANCE.createBooleanType
    G |- substitutions |> negation.exp : var Type t

    t = typesubstitution(substitutions, t)

    unify(negation.exp, substitutions, t, boolType)
}

rule Or
    G |- TypeSubstitutions substitutions |> OrExpression orExp : BooleanType boolType
from {
    boolType = BalzacFactory::eINSTANCE.createBooleanType
    G |- substitutions |> orExp.left : var Type leftType
    G |- substitutions |> orExp.right : var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    unify(orExp.left, substitutions, leftType, boolType)
    unify(orExp.right, substitutions, rightType, boolType)
}

rule And
    G |- TypeSubstitutions substitutions |> AndExpression andExp : BooleanType boolType
from {
    boolType = BalzacFactory::eINSTANCE.createBooleanType
    G |- substitutions |> andExp.left : var Type leftType
    G |- substitutions |> andExp.right : var Type rightType

    leftType = typesubstitution(substitutions, leftType)
    rightType = typesubstitution(substitutions, rightType)

    unify(andExp.left, substitutions, leftType, boolType)
    unify(andExp.right, substitutions, rightType, boolType)
}

rule ArithmeticSigned
    G |- TypeSubstitutions substitutions |> ArithmeticSigned signed : IntType intType
from {
    intType = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> signed.exp : var Type t

    t = typesubstitution(substitutions, t)

    unify(signed.exp, substitutions, t, intType)
}

rule IfThenElse
    G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
    var boolType = BalzacFactory::eINSTANCE.createBooleanType
    G |- substitutions |> stmt.^if: var Type tIf
    G |- substitutions |> stmt.then: var Type tThen
    G |- substitutions |> stmt.^else: var Type tElse

    tIf = typesubstitution(substitutions, tIf)
    tThen = typesubstitution(substitutions, tThen)
    tElse = typesubstitution(substitutions, tElse)

    unify(stmt.^if, substitutions, tIf, boolType)
    unify(stmt.^else, substitutions, tElse, tThen)

    type=tThen
}

rule VerSig
    G |- TypeSubstitutions substitutions |> Versig versig : BalzacFactory::eINSTANCE.createBooleanType
from {
    var sigType = BalzacFactory::eINSTANCE.createSignatureType

    for (s : versig.signatures) {
        G |- substitutions |> s : var Type ts
        ts = typesubstitution(substitutions, ts)
        unify(s, substitutions, ts, sigType)
    }

    var pubkeyType =  BalzacFactory::eINSTANCE.createPubkeyType

    for (k : versig.pubkeys) {
        G |- substitutions |> k : var Type t
        t = typesubstitution(substitutions, t)
        unify(k, substitutions, t, pubkeyType)
    }
}

rule Signature
    G |- TypeSubstitutions substitutions |> Signature s : BalzacFactory::eINSTANCE.createSignatureType
from {
    var keyType = BalzacFactory::eINSTANCE.createKeyType

    G |- substitutions |> s.privkey : var Type t
    t = typesubstitution(substitutions, t)
    unify(s.privkey, substitutions, t, keyType)

    if (s.tx !== null) {
        var txType = BalzacFactory::eINSTANCE.createTransactionType

        G |- substitutions |> s.tx : var Type t1
        t1 = typesubstitution(substitutions, t1)
        unify(s.tx, substitutions, t1, txType)
    }
}

rule Hash160
    G |- TypeSubstitutions substitutions |> Hash160 hash: BalzacFactory::eINSTANCE.createHashType
from {
    G |- substitutions |> hash.value: var Type t
    t = typesubstitution(substitutions, t)

    if (!(t instanceof HashableType)) {
        fail
        error "Invalid type "+stringRep(t)
        source hash.value
    }
}

rule Hash256
    G |- TypeSubstitutions substitutions |> Hash256 hash: BalzacFactory::eINSTANCE.createHashType
from {
    G |- substitutions |> hash.value: var Type t
    t = typesubstitution(substitutions, t)

    if (!(t instanceof HashableType)) {
        fail
        error "Invalid type "+stringRep(t)
        source hash.value
    }
}

rule Ripemd160
    G |- TypeSubstitutions substitutions |> Ripemd160 hash: BalzacFactory::eINSTANCE.createHashType
from {
    G |- substitutions |> hash.value: var Type t
    t = typesubstitution(substitutions, t)

    if (!(t instanceof HashableType)) {
        fail
        error "Invalid type "+stringRep(t)
        source hash.value
    }
}

rule Sha256
    G |- TypeSubstitutions substitutions |> Sha256 hash: BalzacFactory::eINSTANCE.createHashType
from {
    G |- substitutions |> hash.value: var Type t
    t = typesubstitution(substitutions, t)

    if (!(t instanceof HashableType)) {
        fail
        error "Invalid type "+stringRep(t)
        source hash.value
    }
}

rule Sha1
    G |- TypeSubstitutions substitutions |> Sha1 hash: BalzacFactory::eINSTANCE.createHashType
from {
    G |- substitutions |> hash.value: var Type t
    t = typesubstitution(substitutions, t)

    if (!(t instanceof HashableType)) {
        fail
        error "Invalid type "+stringRep(t)
        source hash.value
    }
}
rule Min
    G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
    t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> min.left: var Type tleft
    G |- substitutions |> min.right: var Type tright

    tleft = typesubstitution(substitutions, tleft)
    tright = typesubstitution(substitutions, tright)

    unify(min.left, substitutions, tleft, t)
    unify(min.right, substitutions, tright, t)
}

rule Max
    G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
    t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> max.left: var Type tleft
    G |- substitutions |> max.right: var Type tright

    tleft = typesubstitution(substitutions, tleft)
    tright = typesubstitution(substitutions, tright)

    unify(max.left, substitutions, tleft, t)
    unify(max.right, substitutions, tright, t)
}

rule Between
    G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
    t = BalzacFactory::eINSTANCE.createIntType
    G |- substitutions |> between.value: var Type tValue
    G |- substitutions |> between.left: var Type tLeft
    G |- substitutions |> between.right: var Type tRight

    tValue = typesubstitution(substitutions, tValue)
    tLeft = typesubstitution(substitutions, tLeft)
    tRight = typesubstitution(substitutions, tRight)

    unify(between.value, substitutions, tValue, t)
    unify(between.left, substitutions, tLeft, t)
    unify(between.right, substitutions, tRight, t)
}

rule Size
    G |- TypeSubstitutions substitutions |> Size size: BalzacFactory::eINSTANCE.createIntType
from {
    G |- substitutions |> size.value: var Type t

    t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
    G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
    G |- substitutions |> after.timelock: var Type t

    G |- substitutions |> after.continuation: texpr
    texpr = typesubstitution(substitutions, texpr)
}


rule Compile
    G |- TypeSubstitutions substitutions |> Eval compile: BalzacFactory::eINSTANCE.createVoidType
from {
    for (e : compile.exps) {
        G |- substitutions |> e: var Type texpr
        texpr = typesubstitution(substitutions, texpr)
        failIfNotBasic(texpr, e)
    }
}


rule TransactionInputOperation
    G |- TypeSubstitutions substitutions |> TransactionInputOperation op: BalzacFactory::eINSTANCE.createIntType
from {
    {
        // we can deal with it in the interpreter
        op.tx instanceof This
        EcoreUtil2.getContainerOfType(op, Input) === null   // condition 2

        if (substitutions.isAlreadyVisited(op)) {
            fail
                error "Found cyclic dependency"
                source op
        }

        // check that evaluation of input tx does not cause a loop
        substitutions.addVisited(op)
        val tx = EcoreUtil2.getContainerOfType(op, Transaction)
        val indexes = if (op.indexes.^empty) 0 ..< tx.inputs.size else op.indexes.filter[i|i>=tx.inputs.size].toSet
        for(index : indexes) {
            val inTx = tx.inputs.get(index.intValue).txRef
            G |- substitutions |> inTx: var Type type
        }
        substitutions.removeVisited(op)
    }
    or {
        val txType = BalzacFactory::eINSTANCE.createTransactionType
        G |- substitutions |> op.tx: var Type type
        unify(op.tx, substitutions, type, txType)
    }
}

rule TransactionOutputOperation
    G |- TypeSubstitutions substitutions |> TransactionOutputOperation op: BalzacFactory::eINSTANCE.createIntType
from {
    {
        // we can deal with it in the interpreter
        op.tx instanceof This
        EcoreUtil2.getContainerOfType(op, Output) === null   // condition 2

        if (substitutions.isAlreadyVisited(op)) {
            fail
                error "Found cyclic dependency"
                source op
        }

        // check that evaluation of output values does not cause a loop
        substitutions.addVisited(op)
        val tx = EcoreUtil2.getContainerOfType(op, Transaction)
        val indexes = if (op.indexes.^empty) 0 ..< tx.outputs.size else op.indexes.filter[i|i>=tx.outputs.size].toSet
        for(index : indexes) {
            val vExp = tx.outputs.get(index.intValue).value.exp
            G |- substitutions |> vExp: var Type type
        }
        substitutions.removeVisited(op)
    }
    or {
        val txType = BalzacFactory::eINSTANCE.createTransactionType
        G |- substitutions |> op.tx: var Type type
        unify(op.tx, substitutions, type, txType)
    }
}

/*
 *
 * rule invocations
 *
 */

checkrule CheckModel for
    Model model
from {
    lambdaUtils.resetCounter
    val G = new RuleEnvironment
    val substitutions = new TypeSubstitutions
    val declarations = model.declarations
    
    // type check all constants firsts
    for (c : declarations.filter(Constant)) {
        G |- substitutions |> c: var Type t
    }

    // type check all transactions
    for (tx : declarations.filter(Transaction)) {
        G |- substitutions |> tx: var Type t
    }

    // finally eval expressions
    if (model.eval !== null)
        for (e : model.eval.exps) {
            G |- substitutions |> e: var Type texpr
            texpr = typesubstitution(substitutions, texpr)
            failIfNotBasic(texpr, e)    
        }
}