/*
 * generated by Xtext 2.11.0
 */
package it.unica.tcs.validation

import it.unica.tcs.bitcoinTM.BitcoinTMPackage
import it.unica.tcs.bitcoinTM.KeyBody
import it.unica.tcs.bitcoinTM.KeyDeclaration
import it.unica.tcs.bitcoinTM.Script
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.TransactionBody
import it.unica.tcs.bitcoinTM.TransactionDeclaration
import it.unica.tcs.bitcoinTM.TransactionReference
import it.unica.tcs.bitcoinTM.Versig
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

import static extension it.unica.tcs.validation.BitcoinJUtils.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BitcoinTMValidator extends AbstractBitcoinTMValidator {

	/*
	 * INFO
	 */
	
	@Check
	def void checkEmptyLambda(Script script) {
		if (script.isLambda && script.params.size==0)
			info("Empty lambdas can be omitted.", 
				BitcoinTMPackage.Literals.SCRIPT__PARAMS
			);
	}
	
	@Check
	def void checkSingleElementArray(TransactionBody tbody) {
		
		var input = tbody.input
		var witness = tbody.witness
		var output = tbody.output
		var value = tbody.value
		
		if (input.isMulti && input.txs.size==1) {
			info("Single element arrays can be replaced by the element itself.",
				BitcoinTMPackage.Literals.TRANSACTION_BODY__INPUT
			);	
		}
		
		if (witness.isMulti && witness.scripts.size==1) {
			info("Single element arrays can be replaced by the element itself.", 
				BitcoinTMPackage.Literals.TRANSACTION_BODY__WITNESS
			);	
		}
		
		if (output.isMulti && output.scripts.size==1) {
			info("Single element arrays can be replaced by the element itself.", 
				BitcoinTMPackage.Literals.TRANSACTION_BODY__OUTPUT
			);	
		}
		
		if (value.isMulti && value.values.size==1) {
			info("Single element arrays can be replaced by the element itself.", 
				BitcoinTMPackage.Literals.TRANSACTION_BODY__VALUE
			);	
		}
	}

	/*
	 * WARNING
	 */
	@Check
	def void checkIncompleteKey(KeyBody kbody){
		var pvt = kbody.pvt.value
		var pub = kbody.pub.value
		
		if (pvt == "_" && pub == "_") {
			warning("This key cannot be used anywhere.",
				kbody.eContainer,
				BitcoinTMPackage.Literals.KEY_DECLARATION__BODY
			);
		}		
	}
	
	/*
     * ERROR
     */
	
    @Check
	def void checkTransactionNameIsUnique(TransactionDeclaration t) {
		
		var root = EcoreUtil2.getRootContainer(t);
		for (other: EcoreUtil2.getAllContentsOfType(root, TransactionDeclaration)){
			
			if (t!=other && t.getName.equals(other.name)) {
				error("Transaction names must be unique.", 
					BitcoinTMPackage.Literals.TRANSACTION_DECLARATION__NAME
				);
			}
		}
	} 
    
    @Check
	def void checkKeyNameIsUnique(KeyDeclaration t) {
		
		var root = EcoreUtil2.getRootContainer(t);
		for (other: EcoreUtil2.getAllContentsOfType(root, KeyDeclaration)){
			
			if (t!=other && t.getName.equals(other.name)) {
				error("Key names must be unique.", 
					BitcoinTMPackage.Literals.KEY_DECLARATION__NAME
				);
			}
		}
	}
	
	@Check
	def void checkUnbalancedInputsAndOutputs(TransactionBody tbody) {
		
		var inputs = tbody.input.txs
		var witnesses = tbody.witness.scripts
						
		if (inputs.size != witnesses.size) {
			error("Inputs and witnesses must have the same size.", 
				BitcoinTMPackage.Literals.TRANSACTION_BODY__INPUT
			);	
		}
		
		var outputs = tbody.output.scripts
		var values = tbody.value.values
		
		if (outputs.size != values.size) {
			error("Output and values must have the same size.", 
				BitcoinTMPackage.Literals.TRANSACTION_BODY__OUTPUT
			);	
		}
		
	}
	
	@Check
	def void checkVerSig(Versig versig) {
		
		if (versig.pubkeys.size>15) {
			error("Cannot verify more than 15 public keys.", 
				BitcoinTMPackage.Literals.VERSIG__PUBKEYS
			);
		}
		
		if (versig.signatures.size > versig.pubkeys.size) {
			error("The number of signatures cannot exceed the number of public keys.", 
				versig,
				BitcoinTMPackage.Literals.VERSIG__SIGNATURES
			);
		}
		
		for(var i=0; i<versig.pubkeys.size; i++) {
			var k = versig.pubkeys.get(i).body
			
			if (k.pvt.value===null && k.pub.value===null) {
				error("The referred public key is not declared and cannot be computed by the private one.", 
					versig,
					BitcoinTMPackage.Literals.VERSIG__PUBKEYS,
					i
				);
			}
		}		
	}
	
	@Check
	def void checkSign(Signature sig) {
		var k = sig.key.body
		
		if (k.pvt.value===null) {
			error("The referred private key is not declared.", 
				sig,
				BitcoinTMPackage.Literals.SIGNATURE__KEY
			);
		}
	}
	
	@Check
	def void checkInputIndex(TransactionReference tref) {
		
		/* 
		 * TODO: quando sarà possibile deserializzare le transazioni il check
		 * considerà anche questo caso 
		 */
		if (tref.txid.body===null)
			return;
		
		var numOfOutput = tref.txid.body.output.scripts.size
		
		if (tref.idx>=numOfOutput) {
			error("This input is pointing to an undefined output script.", 
				BitcoinTMPackage.Literals.TRANSACTION_REFERENCE__IDX
			);
		}
	}
	
	@Check
	def void checkKeyDeclaration(KeyDeclaration keyDecl) {
		
		var pvtKey = keyDecl.body.pvt.value;
		var pubKey = keyDecl.body.pub.value;
		
		if (pvtKey !== null && !pvtKey.isValidKey) {
			error("Invalid encoding of the private key. The string must represent a valid bitcon address or hex-characters.",
				keyDecl.body.pvt,
				BitcoinTMPackage.Literals.PRIVATE_KEY__VALUE
			);
		}
		
		if (pubKey !== null && !pubKey.isValidKey) {
			error("Invalid encoding of the public key. The string must represent a valid bitcon address or hex-characters.",
				keyDecl.body.pub,
				BitcoinTMPackage.Literals.PUBLIC_KEY__VALUE
			);
		}
		
		/*
		 * TODO: verificare che le chiavi siano una coppia valida 
		 */
	}
	
}




