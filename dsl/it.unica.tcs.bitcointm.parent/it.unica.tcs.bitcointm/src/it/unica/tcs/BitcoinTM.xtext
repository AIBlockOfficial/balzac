grammar it.unica.tcs.BitcoinTM with org.eclipse.xtext.common.Terminals

generate bitcoinTM "http://www.unica.it/tcs/BitcoinTM"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
    
Model:
	PackageDeclaration;

PackageDeclaration:
    'package' name=QualifiedName
    	imports+=Import*
		net=Network?
		declarations+=Declaration*
;

QualifiedName: ID ('.' ID)*;

Import:
    'import' importedNamespace=QualifiedNameWithWildcard;
    
QualifiedNameWithWildcard:
    QualifiedName '.*'?;

Declaration:
	KeyDeclaration | TransactionDeclaration; 

Network:
	{Network} "network" (testnet?="testnet" | "mainnet");

/*
 * keys
 */
KeyDeclaration: 
	{KeyDeclaration} "key" name=ID "=" body=KeyBody;///*|VerboseKeyBody*/);

KeyBody: "[" pvt=PrivateKey "," pub=PublicKey "]";
VerboseKeyBody returns KeyBody: 
	"{" 
		(("private" ":" pvt=PrivateKey "," "public" ":" pub=PublicKey) |
		("public" ":" pub=PublicKey "," "private" ":" pvt=PrivateKey))	
	"}";
	
PrivateKey: value=STRING | {PrivateKey} "_";
PublicKey: value=STRING  | {PublicKey}  "_";

/*
 * transactions
 */
TransactionDeclaration:
	"transaction" name=ID '=' body=TxBody;

TxBody: SerialTxBody | DummyTxBody | UserDefinedTxBody;

DummyTxBody: {DummyTxBody} "_";
SerialTxBody: bytes=STRING;
UserDefinedTxBody: "{"
	"input"  "=" (inputs+=Input  | (isMultiIn?="["  inputs+=Input   (";" inputs+=Input)*   "]") )
	"output" "=" (outputs+=Output| (isMultiOut?="[" outputs+=Output (";" outputs+=Output)* "]") )
	("tlock" "=" tlock=Tlock)?
"}";



Input:
	txRef=TransactionReference ":" (exps+=Atomic)+ ("["redeemScript=Script"]")?;

Output:
	value=BitcoinValue ":" script=Script;

BitcoinValue:
	exp=Expression;

Tlock:
	value=INT;

TransactionReference:
	tx=[TransactionDeclaration|QualifiedName] ("@" idx=INT)?;

	


Script:
	(lambda?="fun"  "(" (params+=Parameter ("," params+=Parameter)*)? ")" ".")? exp=Expression;

Parameter:
	name=ID (":" paramType=ParameterType)?;


/*
 * expressions
 */
Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} => '||' ) right=AndExpression)*;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*;

Comparison returns Expression:
       Equals (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition (({Equals.left=current} op=("==" | "!=") ) right=Addition)*;
 
Addition returns Expression:
    Prefixed (({Plus.left=current} '+' | {Minus.left=current} '-') right=Prefixed)*; 

Prefixed returns Expression:
    {BooleanNegation} =>"!" exp=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" exp=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    Literal |
    VariableReference |
    Signature |
	Versig |
	Hash |
	IfThenElse |
	Min | Max | Between |
	Size |
	AfterTimeLock;

VariableReference: ref=[Parameter];

Literal:
	NumberLiteral | 
	StringLiteral | 
	BooleanLiteral |
	HashLiteral;

NumberLiteral: value=Number;
StringLiteral: value=STRING;
BooleanLiteral: ^true?='true' | {BooleanLiteral} 'false';
HashLiteral: value=BTC_HASH;

IfThenElse:
	'if' if=Expression
	"then" then=Atomic
	(=> 'else' else=Atomic)?;

Signature: "sig" key=[KeyDeclaration|QualifiedName] (modifier=Modifier)?;

enum Modifier: 
	AIAO | 
	AISO | 
	AINO | 
	SIAO | 
	SISO |
	SINO 
;
	
Versig:
	"versig" "(" 
		pubkeys+=[KeyDeclaration|QualifiedName] ("," pubkeys+=[KeyDeclaration|QualifiedName])* ";"
		signatures+=Expression ("," signatures+=Expression)* 
	")";

Hash: type=('sha256'|'ripemd160'|'hash256'|'hash160') "(" value=Expression ")";

Min: "min" "(" left=Expression "," right=Expression ")";
Max: "max" "(" left=Expression"," right=Expression ")";
Between: "between" "(" value=Expression "," left=Expression":" right=Expression ")";
Size: "size" "(" value=Expression ")";
AfterTimeLock: "after" time=Expression ":" continuation=Atomic;


ParameterType returns Type:
	BasicType;

Type:
	BasicType |
	TypeVariable;

BasicType:
	{IntType} value=IntTypeEnum |
	{HashType} value=HashTypeEnum |
    {StringType} value=StringTypeEnum |
    {BooleanType} value=BoolTypeEnum |
    {SignatureType} value=SignatureTypeEnum;

TypeVariable:
	value=ID;

enum IntTypeEnum: int;
enum HashTypeEnum: hash;
enum StringTypeEnum: string;
enum BoolTypeEnum: bool | boolean;
enum SignatureTypeEnum: signature;



/*
 * Terminal rules copied from Xbase
 */
Number returns ecore::EInt:
	INT ('.' INT)? "BTC"?
	| HEX;

terminal HEX returns ecore::EBigInteger:
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F'|'_')+;	// java-like hexadecimal number

@Override	
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9'|'_')*; 	// java-like integer

terminal BASE58: 
	'base58:' ('1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'J'|'K'|'L'|'M'|'N'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z')+;

terminal BTC_HASH returns ecore::EByteArray: SHA256 | RIPEMD160 | HASH256 | HASH160;
terminal SHA256:	'sha256:'    ('0'..'9'|'a'..'f'|'A'..'F'|'_')+;
terminal RIPEMD160: 'ripemd160:' ('0'..'9'|'a'..'f'|'A'..'F'|'_')+;
terminal HASH256:   'hash256:'   ('0'..'9'|'a'..'f'|'A'..'F'|'_')+;
terminal HASH160:   'hash160:'   ('0'..'9'|'a'..'f'|'A'..'F'|'_')+;
	
