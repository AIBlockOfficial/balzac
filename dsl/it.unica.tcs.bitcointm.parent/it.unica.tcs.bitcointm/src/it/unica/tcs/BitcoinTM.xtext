grammar it.unica.tcs.BitcoinTM with org.eclipse.xtext.common.Terminals

generate bitcoinTM "http://www.unica.it/tcs/BitcoinTM"

Model:
	transactions+=Element*;
	
Element:
	Key | TransactionDeclaration ;

	
TransactionDeclaration:
	"transaction" name=ID '=' ( ('{' body=TransactionBody	'}') | bytes=STRING );

Key: "key" name=ID "=" "(" private=STRING "," public=STRING ")";

TransactionBody:
	input=InputDeclaration
	witness=WitnessDeclaration
	outputs=OutputDeclaration
	values=ValueDeclaration
	(tlock=TlockDeclaration)?
	;

InputDeclaration: 
	"in" ":" (Input | MultipleInput);

WitnessDeclaration:
	"wit" ":" (Witness | MultipleWitness);

OutputDeclaration:
	"out" ":" (Output | MultipleOutput);

ValueDeclaration:
	"val" ":" (Val | MultipleVal);

TlockDeclaration:
	"tlock" value=INT;



Input:
	ref=[TransactionDeclaration];

MultipleInput returns Input:
	"[" inputs+=Input ("," inputs+=Input)* "]";

Witness: 
	script=Script;

MultipleWitness: 
	"[" witnesses+=Witness ("," witnesses+=Witness)* "]";

Output:
	script=Script;

MultipleOutput:
	"[" outputs+=Output ("," outputs+=Output)* "]";

Val: 
	value=Value;

MultipleVal:
	"[" vals+=Val ("," outputs+=Val)* "]";



// da rivedere Script con il nuovo modello
Script:
	("lambda" "(" (params+=Parameter ("," params+=Parameter)*)? ")" ".")? 
	exp=Expression
;


Value:
	value=INT unit=("BTC"|"satoshi")?;


Parameter:
	name=ID (":" paramType=Type)?
;



Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} => '||' ) right=AndExpression)*;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*;

Comparison returns Expression:
       Equals (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
    Prefixed (({Plus.left=current} '+' | {Minus.left=current} '-') right=Prefixed)*; 

Prefixed returns Expression:
    {BooleanNegation} =>"!" exp=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" exp=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    NumberLiteral |
    StringLiteral |
    BooleanLiteral |
    VariableReference |
    Signature |
	Versig |
	Hash |
	IfThenElse |
	Min | Max | Between |
	Size |
	AfterTimeLock;

VariableReference: ref=[Parameter];
NumberLiteral: value=INT;
StringLiteral: value=STRING;
BooleanLiteral: value=('true'|'false');

IfThenElse:
	'if' if=Expression
	"then" then=Atomic
	(=> 'else' else=Atomic)?;

Signature: "sig" key=[Key] (modifier=Modifier)?;

Modifier: "AIAO" | "AINO" | "AISO" | "SIAO" | "SINO" | "SISO";
	
Versig:
	"versig" "(" 
		"{" pubkeys+=[Key] ("," pubkeys+=[Key])* "}" ","
		"{" signatures+=Expression ("," signatures+=Expression)* "}" 
	")";

Hash: "hash" "(" value=Expression ")";

Min: "min" "(" left=Expression "," right=Expression ")";
Max: "max" "(" left=Expression"," right=Expression ")";
Between: "between" "(" value=Expression "," left=Expression":" right=Expression ")";
Size: "size" "(" value=Expression ")";
AfterTimeLock: "after" time=Expression ":" continuation=Atomic;



Type:
	BasicType |
	TypeVariable;

BasicType:
	{IntType} value='int' |
    {StringType} value='string' |
    {BooleanType} value=('boolean'|'bool') |
    {SignatureType} value='signature';

TypeVariable:
	typevarName=ID;
