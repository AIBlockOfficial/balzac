grammar it.unica.tcs.BitcoinTM with org.eclipse.xtext.common.Terminals

generate bitcoinTM "http://www.unica.it/tcs/BitcoinTM"

Model:
	net=NetworkDeclaration?
	declarations+=Declaration*;

NetworkDeclaration:
	"network" type=("testnet"|"mainnet");

Declaration:
	KeyDeclaration | TransactionDeclaration; 

/*
 * keys
 */
KeyDeclaration: 
	{KeyDeclaration} "key" name=ID "=" body=(KeyBody|VerboseKeyBody);

KeyBody: "[" pvt=PrivateKey "," pub=PublicKey "]";
VerboseKeyBody returns KeyBody: 
	"{" 
		(("private" ":" pvt=PrivateKey "," "public" ":" pub=PublicKey) |
		("public" ":" pub=PublicKey "," "private" ":" pvt=PrivateKey))	
	"}";
	
PrivateKey: value=STRING | {PrivateKey} "_";
PublicKey: value=STRING  | {PublicKey}  "_";

/*
 * transactions
 */
TransactionDeclaration:
	{TransactionDeclaration} "transaction" name=ID '=' ( ('{' body=TransactionBody	'}') | bytes=STRING | "_" );

TransactionBody:
	input=Input
	witness=Witness
	output=Output
	value=Val
	(tlock=Tlock)?;

Input:   "in"    ":" (SingleInput   | MultipleInput);
Witness: "wit"   ":" (SingleWitness | MultipleWitness);
Output:  "out"   ":" (SingleOutput  | MultipleOutput);
Val:     "val"   ":" (SingleVal     | MultipleVal);
Tlock:   "tlock" ":" value=INT;


SingleInput returns Input:
	txs+=TransactionReference;

MultipleInput returns Input:
	multi?="[" txs+=TransactionReference (txs+=TransactionReference)* "]";

SingleWitness returns Witness: 
	scripts+=WitnessScript;

MultipleWitness returns Witness: 
	multi?="[" scripts+=(WitnessScript) (";" scripts+=WitnessScript)* "]";

SingleOutput returns Output:
	scripts+=OutputScript;

MultipleOutput returns Output:
	multi?="[" scripts+=OutputScript (";" scripts+=OutputScript)* "]";

SingleVal returns Val: 
	values+=Value;

MultipleVal returns Val:
	multi?="[" values+=Value ("," values+=Value)* "]";



TransactionReference:
	txid=[TransactionDeclaration] ("@" idx=INT)?;

WitnessScript:
	{WitnessScript} //("{" => redeemScript=Script "}")? 
	(exps+=Expression ("," exps+=Expression)*)?;

OutputScript:
	(P2SH?="P2SH" "(" script=Script ")") | script=Script;

Script:
	(lambda?="fun"  "(" (params+=Parameter ("," params+=Parameter)*)? ")" ".")? exp=Expression;


Value:
	value=INT unit=("BTC"|"satoshi")?;

Parameter:
	name=ID (":" paramType=ParameterType)?;


/*
 * expressions
 */
Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} => '||' ) right=AndExpression)*;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*;

Comparison returns Expression:
       Equals (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
    Prefixed (({Plus.left=current} '+' | {Minus.left=current} '-') right=Prefixed)*; 

Prefixed returns Expression:
    {BooleanNegation} =>"!" exp=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" exp=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    NumberLiteral |
    StringLiteral |
    BooleanLiteral |
    VariableReference |
    Signature |
	Versig |
	Hash |
	IfThenElse |
	Min | Max | Between |
	Size |
	AfterTimeLock;

VariableReference: ref=[Parameter];
NumberLiteral: value=INT;
StringLiteral: value=STRING;
BooleanLiteral: value=('true'|'false');

IfThenElse:
	'if' if=Expression
	"then" then=Atomic
	(=> 'else' else=Atomic)?;

Signature: "sig" key=[KeyDeclaration] (modifier=Modifier)?;

Modifier: "AIAO" | "AINO" | "AISO" | "SIAO" | "SINO" | "SISO";
	
Versig:
	"versig" "(" 
		pubkeys+=[KeyDeclaration] ("," pubkeys+=[KeyDeclaration])* ";"
		signatures+=Expression ("," signatures+=Expression)* 
	")";

Hash: "hash" "(" value=Expression ")";

Min: "min" "(" left=Expression "," right=Expression ")";
Max: "max" "(" left=Expression"," right=Expression ")";
Between: "between" "(" value=Expression "," left=Expression":" right=Expression ")";
Size: "size" "(" value=Expression ")";
AfterTimeLock: "after" time=Expression ":" continuation=Atomic;


ParameterType returns Type:
	BasicType;

Type:
	BasicType |
	TypeVariable;

BasicType:
	{IntType} value='int' |
    {StringType} value='string' |
    {BooleanType} value=('boolean'|'bool') |
    {SignatureType} value='signature';

TypeVariable:
	value=ID;
