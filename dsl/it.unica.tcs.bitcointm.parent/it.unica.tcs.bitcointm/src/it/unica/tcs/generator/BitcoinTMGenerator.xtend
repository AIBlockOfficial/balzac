/*
 * generated by Xtext 2.11.0
 */
package it.unica.tcs.generator

import com.google.inject.Inject
import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Declaration
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.HashLiteral
import it.unica.tcs.bitcoinTM.HashType
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.KeyDeclaration
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.Model
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Output
import it.unica.tcs.bitcoinTM.PackageDeclaration
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Script
import it.unica.tcs.bitcoinTM.SerialTxBody
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.TransactionDeclaration
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.UserDefinedTxBody
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.util.ASTUtils
import it.unica.tcs.xsemantics.BitcoinTMTypeSystem
import java.io.File
import org.bitcoinj.core.DumpedPrivateKey
import org.bitcoinj.core.NetworkParameters
import org.bitcoinj.core.Transaction
import org.bitcoinj.core.Transaction.SigHash
import org.bitcoinj.core.Utils
import org.bitcoinj.script.Script.ScriptType
import org.bitcoinj.script.ScriptBuilder
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static org.bitcoinj.script.ScriptOpCodes.*

import static extension it.unica.tcs.util.ASTUtils.*
import static extension it.unica.tcs.validation.BitcoinJUtils.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BitcoinTMGenerator extends AbstractGenerator {

//	@Inject private extension IQualifiedNameProvider
    @Inject private extension ASTUtils astUtils
	@Inject private extension BitcoinTMTypeSystem typeSystem
	@Inject private extension Optimizer optimizer
	
    
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

        var resourceName = resource.URI.lastSegment.replace(".btm", "")

        for (e : resource.allContents.toIterable.filter(Model)) {

//			var basepath = if (e.^package==null) "" else e.^package.fullyQualifiedName.toString(File.separator) ;
            var outputFilename = "" + File.separator + resourceName + ".test"

            fsa.generateFile(outputFilename, e.compile)
        }
    }

    def dispatch String compile(EObject obj) {
        throw new CompileException
    }

    	
    def dispatch String compile(PackageDeclaration obj) {
        obj.declarations.map[x|
//        	println(x)
        	x.compile
        ].join("\n")
    }

    def dispatch String compile(KeyDeclaration obj) {
        '''key «obj.name»'''
    }

	def dispatch String compile(Declaration obj) {
		// TODO
    }
    
    def dispatch String compile(TransactionDeclaration obj) {

    	var tx = obj.toTransaction

    	if (obj.body instanceof SerialTxBody)
    		return '''transaction «obj.name» [«(obj.body as SerialTxBody).bytes»]'''
    	
    	
		'''
		transaction «obj.name» {
			
			«tx.toString»
			
		} [«Utils.HEX.encode(tx.bitcoinSerialize)»]
		
		'''
    }


    
    
    
    
    
    
    
	

    /*
     * 
     * compiler: AST --> BitcoinJ
     * 
     */
    
	def Transaction toTransaction(TransactionDeclaration stmt) {
		// TODO
		null
	}




    def ITransactionBuilder compileTransaction(TransactionDeclaration txDecl) {
    	return txDecl.body.compileTransactionBody;
    }
    
    def dispatch ITransactionBuilder compileTransactionBody(UserDefinedTxBody tx) {
    	
    	val tb = 
    		if (tx.isCoinbase) new CoinbaseTransactionBuilder	    	
	    	else new TransactionBuilder
    	
    	// free variables
    	for (param : tx.params) {
    		tb.freeVariable(param.name, param.paramType.convertType)
    	} 		
    	
    	// inputs
    	for(input : tx.inputs) {
    		val parentTx = input.txRef.tx.compileTransaction	// recursive call
    		val outIndex = input.txRef.idx
    		val inScript = input.compileInput(new Context)
    		
    		// relative timelock
    		if (tx.tlock!==null && tx.tlock.containsRelative(tx.eContainer as TransactionDeclaration)) {
				val locktime = tx.tlock.getRelative(tx.eContainer as TransactionDeclaration)
				tb.addInput(parentTx, outIndex, inScript, locktime)
    		}
    		else {
    			tb.addInput(parentTx, outIndex, inScript)
    		}
    	}
    	
    	// outputs
    	for (output : tx.outputs) {
    		val outScript = output.compileOutput(new Context)
    		val satoshis = output.value.exp.interpret.first as Integer
    		tb.addOutput(outScript, satoshis)
    	}
    	
    	// absolute timelock
    	if (tx.tlock!==null && tx.tlock.containsAbsolute)
	        tb.locktime = tx.tlock.getAbsolute()
    	
    	return tb
    }
    
    def dispatch ITransactionBuilder compileTransactionBody(SerialTxBody tx) {
    	return new ITransactionBuilder{
    		override boolean isReady() {true}
			override Transaction toTransaction(NetworkParameters params) {
				new Transaction(tx.networkParams, Utils.HEX.decode(tx.bytes))
			}
    	}
    }

    def ScriptBuilder2 compileInput(Input stmt, Context ctx) {

		if (stmt.isPlaceholder) {
 			/*
             * This transaction is like a coinbase transaction.
             * You can put the input you want.
             */
            return new ScriptBuilder2().number(42)
		}
		else {
	        var outIdx = stmt.txRef.idx
			switch stmt.txRef.tx.body {
				
				/*
				 * User defined transaction.
				 * Return the expected inputs based on the kind of output script
				 */
				UserDefinedTxBody: {
					var inputTx = stmt.txRef.tx.body as UserDefinedTxBody       
		            var output = inputTx.outputs.get(outIdx);
		    
		            if (output.script.isP2PKH) {
		                var sig = stmt.exps.get(0).simplifySafe as Signature
		                var pubkey = sig.key.body.pvt.value.privateKeyToPubkeyBytes(stmt.networkParams)
		                
		                var sb = sig.compileInputExpression(ctx)
		                sb.data(pubkey)
		    
		                /* <sig> <pubkey> */
		                sb
		            } else if (output.script.isP2SH) {
		            	
		                val sb = new ScriptBuilder2()
		                
		                // build the list of expression pushes (actual parameters) 
		                stmt.exps.forEach[e|
		                	sb.append(e.simplifySafe.compileInputExpression(ctx))
		                ]
		                
		                // get the redeem script to push
		                var redeemScript = output.script.getRedeemScript(ctx)
		                
		                sb.data(redeemScript.build.program)
		                                
		                /* <e1> ... <en> <serialized script> */
		                sb
		            } else
		                throw new CompileException
	            }
	            
				/*
				 * Serialized transaction.
				 * Return the expected inputs based on the kind of output script
				 */
	            SerialTxBody: {
	            	var output = stmt.txRef.tx.toTransaction.getOutput(outIdx)
	            
		            if (output.scriptPubKey.isSentToAddress) {
		                var sig = (stmt.exps.get(0) as Expression).simplifySafe as Signature
		                var pubkey = sig.key.body.pvt.value.privateKeyToPubkeyBytes(stmt.networkParams)
		                
		                var sb = sig.compileInputExpression(ctx)
		                sb.data(pubkey)
		    
		                /* <sig> <pubkey> */
		                sb
		            } else if (output.scriptPubKey.isPayToScriptHash) {
		                
		                val sb = new ScriptBuilder2()
		                
		                // build the list of expression pushes (actual parameters) 
		                stmt.exps.forEach[e|
		                	sb.append(e.simplifySafe.compileInputExpression(ctx))
		                ]
		                
		                // get the redeem script to push
		                var redeemScript = stmt.redeemScript.getRedeemScript(ctx)
		                sb.data(redeemScript.build.program)
		                
		                /* <e1> ... <en> <serialized script> */
		                sb
		            } else
		                throw new CompileException
	            }
	            default: throw new CompileException("Unexpected class "+stmt.txRef.tx.body.class)
			}			
		}
    }

	/**
	 * Compile an output based on its "type".
	 */
    def private ScriptBuilder2 compileOutput(Output output, Context ctx) {
		
        var outScript = output.script

        if (outScript.isP2PKH) {
            var versig = outScript.exp.simplifySafe as Versig
            var pk = versig.pubkeys.get(0).body.pub.value.wifToAddress(output.networkParams)

            var script = ScriptBuilder.createOutputScript(pk)

            if (script.scriptType != ScriptType.P2PKH)
                throw new CompileException

            /* OP_DUP OP_HASH160 <pkHash> OP_EQUALVERIFY OP_CHECKSIG */
            new ScriptBuilder2().append(script)
        } else if (outScript.isP2SH) {
            
            // get the redeem script to serialize
            var redeemScript = output.script.getRedeemScript(ctx)
            var script = ScriptBuilder.createP2SHOutputScript(redeemScript.build)

            if (script.scriptType != ScriptType.P2SH)
                throw new CompileException

            /* OP_HASH160 <script hash-160> OP_EQUAL */
            new ScriptBuilder2().append(script)
        } else if (outScript.isOpReturn) {
            var c = outScript.exp as StringLiteral
            var script = ScriptBuilder.createOpReturnScript(c.value.bytes)

            if (script.scriptType != ScriptType.NO_TYPE)
                throw new CompileException

            /* OP_RETURN <bytes> */
            new ScriptBuilder2().append(script)
        } else
            throw new UnsupportedOperationException
    }


	/**
	 * Return the redeem script (in the P2SH case) from the given output.
	 * 
	 * <p>
	 * This function is invoked to generate both the output script (hashing the result) and
	 * input script (pushing the bytes).
	 * <p>
	 * It also prepends a magic number and altstack instruction.
	 */
	def private ScriptBuilder2 getRedeemScript(Script script, Context ctx) {
        
        if (!ctx.altstack.isEmpty)
        	throw new CompileException("Altstack must be empty.")
        
        // build the redeem script to serialize
        var sb = new ScriptBuilder2()
        for (var i=script.params.size-1; i>=0; i--) {
            val Parameter p = script.params.get(i)
            var numberOfRefs = EcoreUtil2.getAllContentsOfType(script.exp, VariableReference).filter[v|v.ref==p].size 
            
            ctx.altstack.put(p, AltStackEntry.of(ctx.altstack.size, numberOfRefs))    // update the context
            
            sb.op(OP_TOALTSTACK)
        }
        
        sb.append(script.exp.simplifySafe.compileExpression(ctx)).optimize
	}
	
	
	/**
	 * Compile an input expression. It must not have free variables
	 */
    def private ScriptBuilder2 compileInputExpression(Expression exp, Context ctx) {
        var refs = EcoreUtil2.getAllContentsOfType(exp, VariableReference)
        
        // the altstack is used only by VariableReference(s)
        if (!refs.empty)
        	throw new CompileException("The given expression must not have free variables.")
        
        if (!ctx.altstack.isEmpty)
        	throw new CompileException("Altstack must be empty.")
        
        exp.simplifySafe.compileExpression(ctx).optimize
    }
    
    /*
     * EXPRESSIONS
     * 
     * N.B. the compiler tries to simplify simple expressions like
     * <ul> 
     *  <li> 1+2 ≡ 3
     *  <li> if (12==10+2) then "foo" else "bar" ≡ "foo"
     * </ul>
     */
    def private dispatch ScriptBuilder2 compileExpression(Expression exp, Context ctx) {
        throw new CompileException
    }
    
    def private dispatch ScriptBuilder2 compileExpression(KeyDeclaration stmt, Context ctx) {
        /* push the public key */
        val pvtkey = stmt.body.pvt.value
        val key = DumpedPrivateKey.fromBase58(stmt.networkParams, pvtkey).key

        new ScriptBuilder2().data(key.pubKey)
    }

    def private dispatch ScriptBuilder2 compileExpression(Hash hash, Context ctx) {
        var res = typeSystem.interpret(hash)
        
        if (res.failed) {
		    var sb = hash.value.compileExpression(ctx)
	        
	        switch(hash.type) {
	        	case "sha256":	 	sb.op(OP_SHA256)
	        	case "ripemd160":	sb.op(OP_RIPEMD160)
	        	case "hash256":	 	sb.op(OP_HASH256)
	        	case "hash160":		sb.op(OP_HASH160)
	        }
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(AfterTimeLock stmt, Context ctx) {
        var sb = new ScriptBuilder()
        sb.number(stmt.timelock.value)
        sb.op(OP_CHECKLOCKTIMEVERIFY)
        sb.op(OP_DROP)
        stmt.continuation.compileExpression(ctx)
    }

    def private dispatch ScriptBuilder2 compileExpression(AndExpression stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
	        var sb = stmt.left.compileExpression(ctx)
	        sb.append(stmt.right.compileExpression(ctx))
	        sb.op(OP_BOOLAND)            
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(OrExpression stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
	        var sb = stmt.left.compileExpression(ctx)
	        sb.append(stmt.right.compileExpression(ctx))
	        sb.op(OP_BOOLOR)            
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Plus stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.left.compileExpression(ctx)
            sb.append(stmt.right.compileExpression(ctx))
            sb.op(OP_ADD)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Minus stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.left.compileExpression(ctx)
            sb.append(stmt.right.compileExpression(ctx))
            sb.op(OP_SUB)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Max stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.left.compileExpression(ctx)
            sb.append(stmt.right.compileExpression(ctx))
            sb.op(OP_MAX)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Min stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.left.compileExpression(ctx)
            sb.append(stmt.right.compileExpression(ctx))
            sb.op(OP_MIN)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Size stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
	        var sb = stmt.value.compileExpression(ctx)
	        sb.op(OP_SIZE)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
        
    }

    def private dispatch ScriptBuilder2 compileExpression(BooleanNegation stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.exp.compileExpression(ctx)
            sb.op(OP_NOT)            
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(ArithmeticSigned stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.exp.compileExpression(ctx)
            sb.op(OP_NOT)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Between stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.value.compileExpression(ctx)
            sb.append(stmt.left.compileExpression(ctx))
            sb.append(stmt.right.compileExpression(ctx))
            sb.op(OP_WITHIN)
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Comparison stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.left.compileExpression(ctx)
            sb.append(stmt.right.compileExpression(ctx))
    
            switch (stmt.op) {
                case "<": sb.op(OP_LESSTHAN)
                case ">": sb.op(OP_GREATERTHAN)
                case "<=": sb.op(OP_LESSTHANOREQUAL)
                case ">=": sb.op(OP_GREATERTHANOREQUAL)
            }
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }
    
    def private dispatch ScriptBuilder2 compileExpression(Equals stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.left.compileExpression(ctx)
            sb.append(stmt.right.compileExpression(ctx))
            
            switch (stmt.op) {
                case "==": sb.op(OP_EQUAL)
                case "!=": sb.op(OP_EQUAL).op(OP_NOT)
            }
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(IfThenElse stmt, Context ctx) {
        var res = typeSystem.interpret(stmt)
        
        if (res.failed) {
            var sb = stmt.^if.compileExpression(ctx)
            sb.op(OP_IF)
            sb.append(stmt.then.compileExpression(ctx))
            sb.op(OP_ELSE)
            sb.append(stmt.^else.compileExpression(ctx))
            sb.op(OP_ENDIF)            
        }
        else {
        	new ScriptBuilder2().append(res)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(Versig stmt, Context ctx) {
        if (stmt.pubkeys.size == 1) {
            var sb = stmt.signatures.get(0).compileExpression(ctx)
            sb.append(stmt.pubkeys.get(0).compileExpression(ctx))
            sb.op(OP_CHECKSIG)
        } else {
            val sb = new ScriptBuilder2().number(OP_0)
            stmt.signatures.forEach[s|sb.append(s.compileExpression(ctx))]
            sb.number(stmt.signatures.size)
            stmt.pubkeys.forEach[k|sb.append(k.compileExpression(ctx))]
            sb.number(stmt.pubkeys.size)
            sb.op(OP_CHECKMULTISIG)
        }
    }

    def private dispatch ScriptBuilder2 compileExpression(NumberLiteral n, Context ctx) {
        new ScriptBuilder2().number(n.value)
    }

    def private dispatch ScriptBuilder2 compileExpression(BooleanLiteral n, Context ctx) {
        if(n.isTrue)
        	new ScriptBuilder2().op(OP_TRUE)
    	else 
    		new ScriptBuilder2().number(OP_FALSE)
    }

    def private dispatch ScriptBuilder2 compileExpression(StringLiteral s, Context ctx) {
        new ScriptBuilder2().data(s.value.bytes)
    }
    
    def private dispatch ScriptBuilder2 compileExpression(HashLiteral s, Context ctx) {
        new ScriptBuilder2().data(s.value)
    }

    def private dispatch ScriptBuilder2 compileExpression(Signature stmt, Context ctx) {
        
		var wif = stmt.key.body.pvt.value
		
		var key = DumpedPrivateKey.fromBase58(stmt.networkParams, wif).getKey();
        var hashType = switch(stmt.modifier) {
                case AIAO,
                case SIAO: SigHash.ALL
                case AISO,
                case SISO: SigHash.SINGLE
                case AINO,
                case SINO: SigHash.NONE
            }
        var anyoneCanPay = switch(stmt.modifier) {
                case SIAO,
                case SISO,
                case SINO: true
                case AIAO,
                case AISO,
                case AINO: false
            }
            
        // store an empty value
        new ScriptBuilder2().signaturePlaceholder(key, hashType, anyoneCanPay)
    }

    def private dispatch ScriptBuilder2 compileExpression(VariableReference varRef, Context ctx) {
        
        /*
         * N: altezza dell'altstack
         * i: posizione della variabile interessata
         * 
         * OP_FROMALTSTACK( N - i )                svuota l'altstack fino a raggiungere x
         * 	                                       x ora è in cima al main stack
         * 
         * OP_DUP OP_TOALTSTACK        	           duplica x e lo rimanda sull'altstack
         * 
         * (OP_SWAP OP_TOALTSTACK)( N - i - 1 )    prende l'elemento sotto x e lo sposta sull'altstack
         * 
         */
        var param = varRef.ref
        
        var isTxParam = param.eContainer instanceof UserDefinedTxBody 
        
        if (isTxParam) {
        	return new ScriptBuilder2().freeVariable(param.name, param.paramType.convertType)
        }
        else {
        	val sb = new ScriptBuilder2()
	        val pos = ctx.altstack.get(param).position
			var count = ctx.altstack.get(param).occurrences
	
	        if(pos === null) throw new CompileException;
	
	        (1 .. ctx.altstack.size - pos).forEach[x|sb.op(OP_FROMALTSTACK)]
	        
	        if (count==1) {
	        	// this is the last usage of the variable
	        	ctx.altstack.remove(param)							// remove the reference to its altstack position
	        	for (e : ctx.altstack.entrySet.filter[e|e.value.position>pos]) {	// update all the positions of the remaing elements
	        		ctx.altstack.put(e.key, AltStackEntry.of(e.value.position-1, e.value.occurrences))
	        	}
	        	
		        if (ctx.altstack.size - pos> 0)
		            (1 .. ctx.altstack.size - pos).forEach[x|sb.op(OP_SWAP).op(OP_TOALTSTACK)]
	        	
	        }
	        else {
	        	ctx.altstack.put(param, AltStackEntry.of(pos, count-1))
		        sb.op(OP_DUP).op(OP_TOALTSTACK)
	
		        if (ctx.altstack.size - pos - 1 > 0)
		            (1 .. ctx.altstack.size - pos - 1).forEach[x|sb.op(OP_SWAP).op(OP_TOALTSTACK)]	            
	        }
	        return sb
        }
    }
    
    
    def static String compileType(Type type) {
    	if(type instanceof IntType) return "Integer"
    	if(type instanceof HashType) return "byte[]"
    	if(type instanceof StringType) return "String"
    	if(type instanceof BooleanType) return "Boolean"
    	if(type instanceof SignatureType) return "byte[]"
    	
    	throw new CompileException("Unexpected type "+type.class.simpleName)
    }
    
	def static Class<?> convertType(Type type) {
    	if(type instanceof IntType) return Integer
    	if(type instanceof HashType) return typeof(byte[])
    	if(type instanceof StringType) return String
    	if(type instanceof BooleanType) return Boolean
    	if(type instanceof SignatureType) return typeof(byte[])
    	
    	throw new CompileException("Unexpected type "+type.class.simpleName)
    }
}
