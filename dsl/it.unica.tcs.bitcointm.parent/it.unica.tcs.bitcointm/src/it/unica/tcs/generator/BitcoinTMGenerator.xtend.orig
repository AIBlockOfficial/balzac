/*
 * generated by Xtext 2.11.0
 */
package it.unica.tcs.generator

import com.google.inject.Inject
import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Declaration
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.HashType
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.KeyDeclaration
import it.unica.tcs.bitcoinTM.Output
import it.unica.tcs.bitcoinTM.PackageDeclaration
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.SerialTxBody
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.TransactionDeclaration
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.UserDefinedTxBody
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.xsemantics.BitcoinTMTypeSystem
import java.io.File
import java.util.HashMap
import java.util.Map
import org.bitcoinj.core.Coin
import org.bitcoinj.core.Transaction
import org.bitcoinj.core.TransactionInput
import org.bitcoinj.core.TransactionOutPoint
import org.bitcoinj.core.TransactionOutput
import org.bitcoinj.core.Utils
import org.bitcoinj.script.Script
import org.bitcoinj.script.Script.ScriptType
import org.bitcoinj.script.ScriptBuilder
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider

import static extension it.unica.tcs.util.ASTUtils.*
import static extension it.unica.tcs.validation.BitcoinJUtils.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BitcoinTMGenerator extends AbstractGenerator {

	@Inject private extension IQualifiedNameProvider
    @Inject private extension BitcoinTMTypeSystem typeSystem
	@Inject private extension ExpressionCompiler expressionCompiler
	@Inject private extension ScriptCompiler scriptCompiler
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

        var resourceName = resource.URI.lastSegment.replace(".btm", "")

        for (package : resource.allContents.toIterable.filter(PackageDeclaration)) {

			var packagePath = package.fullyQualifiedName.toString(File.separator) ;

            fsa.generateFile(packagePath + File.separator + "Transactions.java", package.compile)
            
            generateScriptClasses(package, fsa)
        }
    }
    
    def void generateScriptClasses(PackageDeclaration pkg, IFileSystemAccess2 fsa) {
    	
        var packagePath = pkg.fullyQualifiedName.append("script").toString(File.separator) ;
        
        for (UserDefinedTxBody body : EcoreUtil2.eAllOfType(pkg, UserDefinedTxBody)) {
        	
        	val txName = (body.eContainer as TransactionDeclaration).name
			
			for (var i=0; i<body.outputs.size; i++) {
				val output = body.outputs.get(i)
				val className = '''«txName»_outputScript_«i»'''
		        fsa.generateFile(packagePath + File.separator + className+".java", pkg.compileScript(className, output, body.params))
			}        	
        	
        }
        
    }
    
	def String compileScript(PackageDeclaration pkg, String className, Output output, EList<Parameter> txFreeVariables) {
		val scriptFreeVariables = output.script.params
		val freeVariables = txFreeVariables.toSet
		freeVariables.removeAll(scriptFreeVariables)
		
		'''
			package «pkg.fullyQualifiedName.append("script")»;
			
			import org.bitcoinj.core.*;
			import org.bitcoinj.script.*;
			
			import static org.bitcoinj.script.ScriptOpCodes.*;
			
			public class «className» {
				
				public static Script toScript(«freeVariables.map[p|'''«p.paramType.compile» «p.name»'''].join(", ")») {
					ScriptBuilder sb = new ScriptBuilder();
					
					return sb.build()
				}
			}
		'''
    }    
    
    
    def dispatch String compile(EObject obj) {
        throw new CompileException
    }
    
    def dispatch String compile(Declaration obj) {
        ""
    }

	def dispatch String compile(PackageDeclaration pkg) '''
		package «pkg.fullyQualifiedName»;
		
		import org.bitcoinj.core.*;
		
		public class Transactions {
			
			public static final NetworkParameters params = «IF pkg.net!==null && !pkg.net.isTestnet»NetworkParameters.fromID(NetworkParameters.ID_MAINNET)«ELSE»NetworkParameters.fromID(NetworkParameters.ID_TESTNET)«ENDIF»;
			
			«FOR decl : pkg.declarations»
			«decl.compile»
			
			«ENDFOR»
		}
	'''
	
    	
    def dispatch String compile(KeyDeclaration obj) '''
        public static ECKey getKey_«obj.name»_private() {
        	«IF obj.body.pvt.value!==null»
        	return DumpedPrivateKey.fromBase58(params, "«obj.body.pvt.value»").getKey();
        	«ELSE»
        	return null;
        	«ENDIF»
        }
        
        public static Address getKey_«obj.name»_public() {
        	«IF obj.body.pub.value!==null»
        	return Address.fromBase58(params, "«obj.body.pub.value»");
        	«ELSE»
        	return null;
        	«ENDIF»
        }
    '''

    def dispatch String compile(TransactionDeclaration tx) '''
    	public static Transaction getTransaction_«tx.name»«tx.body.compile»
    	
    '''


    def dispatch String compile(SerialTxBody body) '''
		() {
			byte[] payload = Utils.HEX.decode("«body.bytes»");
			return new Transaction(params, payload);
		}
    '''
	
	def dispatch String compile(UserDefinedTxBody body) '''
		(«body.params.map[p|'''«p.paramType.compile» «p.name»'''].join(", ")») {
			
«««			Map<String, Object> freeVariables = new HashMap<>();
«««			Map<String, Class<?>> freeVariablesTypes = new HashMap<>();
«««			«FOR p:body.params»
«««			freeVariables.put("«p.name»", «p.name»);
«««			freeVariablesTypes.put("«p.name»", «p.paramType.compile».class);
«««			«ENDFOR»

			Transaction tx = new Transaction(params);
		
			«FOR i : 0..<body.inputs.size»
			«val input = body.inputs.get(i)»
«««			Transaction txToRedeem = getTransaction_«input.txRef.tx.name»(«input.txRef.actualParams.map[e|e.compileInputExpression()].join(", ")»);
«««			int outIndex_«i» = «input.txRef.idx»;
«««			TransactionOutPoint txOutPoint_«i» = new TransactionOutPoint(params, outIndex, txToRedeem)
«««			TransactionInput txInput_«i» = new TransactionInput(params, tx, );
«««			
«««			tx.addInput(txInput_«i»);
			«ENDFOR»


			«FOR i : 0..<body.outputs.size»
			«val output = body.outputs.get(i)»
			«val context = new Context»
			««« map the actual parameters to the formal one s»»»
«««			Coin value_«i» = Coin.valueOf(«output.value.exp.interpret.first as Integer»);
«««			Script pubScript_«i» = getOutputScript_«(body.eContainer as TransactionDeclaration).name»_«i»();
«««			TransactionOutput txOutput_«i» = new TransactionOutput(params, tx, value_«i», pubScript_«i».getProgram());
«««			tx.addOutput(txOutput_«i»);
			«ENDFOR»
						
			return tx;
		}
    '''
    
    def dispatch String compile(Type type) {
    	if(type instanceof IntType) return "Integer"
    	if(type instanceof HashType) return "byte[]"
    	if(type instanceof StringType) return "String"
    	if(type instanceof BooleanType) return "Boolean"
    	if(type instanceof SignatureType) return "byte[]"
    	
    	throw new CompileException("Unexpected type "+type.class.simpleName)
    }
    
	def static Class<?> convertType(Type type) {
    	if(type instanceof IntType) return Integer
    	if(type instanceof HashType) return typeof(byte[])
    	if(type instanceof StringType) return String
    	if(type instanceof BooleanType) return Boolean
    	if(type instanceof SignatureType) return typeof(byte[])
    	
    	throw new CompileException("Unexpected type "+type.class.simpleName)
    }

    
    
    
    
    
    
    
    
    /*
     * utility methods
     */
    def boolean isP2PKH(it.unica.tcs.bitcoinTM.Script script) {
        var onlyOneSignatureParam = script.params.size == 1 && (script.params.get(0).paramType instanceof SignatureType)
        var onlyOnePubkey = (script.exp.simplifySafe instanceof Versig) && (script.exp.simplifySafe as Versig).pubkeys.size == 1

        return onlyOneSignatureParam && onlyOnePubkey
    }

    def boolean isOpReturn(it.unica.tcs.bitcoinTM.Script script) {
        var noParam = script.params.size == 0
        var onlyString = script.exp.simplifySafe instanceof StringLiteral

        return noParam && onlyString
    }

    def boolean isP2SH(it.unica.tcs.bitcoinTM.Script script) {
        return !script.isP2PKH && !script.isOpReturn
    }

	

    /*
     * 
     * compiler: AST --> BitcoinJ
     * 
     */
    
    def Transaction toTransaction(TransactionDeclaration stmt) {
		toTransaction(stmt, new BasicEList, new HashMap());
	}
    
	def Transaction toTransaction(TransactionDeclaration stmt, EList<Expression> actualParams) {
		toTransaction(stmt, actualParams, new HashMap());
	}
	
    /**
     * Create a bitcoinj coinbase transaction.
     * The amount of money that can be spend is taken from the network parameters.
     * 
     * @return a coinbase tx with a lot of money always redeemable
     */
    def private Transaction toTransaction(TransactionDeclaration stmt, EList<Expression> actualParams, Map<TransactionDeclaration,Transaction> cache) {
        if (cache.containsKey(stmt))
			return cache.get(stmt)
        
        var netParams = stmt.networkParams
        var tx = new Transaction(netParams);

//       	if (stmt.isCoinbase) {
//       		/*
//       		 * coinbase transaction
//       		 */
//       		var address = stmt.key.body.pub.value.wifToAddress(netParams)
//	        var txInput = new TransactionInput(netParams, tx, new ScriptBuilder().number(42).build().getProgram());
//	        var txOutput = new TransactionOutput(netParams, tx, netParams.maxMoney, ScriptBuilder.createOutputScript(address).program);      
//	    	
//	        tx.addInput(txInput);
//	        tx.addOutput(txOutput);
//	        
//	        if (!tx.isCoinBase)
//	        	throw new CompileError('''the compiled transaction of «stmt.name» is not a coinbase transaction''')
//	        
//	        cache.put(stmt, tx)
//       	}
//       	else {
       		switch(stmt.body) {
       			UserDefinedTxBody: {
       				/**
				     * Create a bitcoinj transaction object recursively.
				     * Each transaction is bound to another one by its inputs. Recursion
				     * stops when either a coinbase transaction or a serialized transaction is reached.
				     */
		       		var body = stmt.body as UserDefinedTxBody
		       		
		       		// the tx is not ready yet but it will be at the end of the recursive loop
        			cache.put(stmt, tx)
        
       				var ctx = new Context
       				
       				// map the actual parameters to the formal ones
       				for(var i=0; i<actualParams.size; i++) {
       					var actual = actualParams.get(i)
       					var formal = body.params.get(i)
       					ctx.transactionParameters.put(formal, actual)
       				}
       				
       				for (var i=0; i<body.inputs.size; i++) {
			//        	println('''input «i»''')
						ctx.clear()
			        	var input = body.inputs.get(i)
			            
			            var TransactionInput txInput = null
			            if (!input.isPlaceholder) {			            	
				            var outIndex = input.txRef.idx
				            var txToRedeem = toTransaction(input.txRef.tx, input.txRef.actualParams, cache)
				            var outPoint = new TransactionOutPoint(netParams, outIndex, txToRedeem)
				            txInput = new TransactionInput(netParams, tx, input.compileInput(ctx).program, outPoint)

				            var hasCheckTimeLockVerify = EcoreUtil2.getAllContentsOfType(input.txRef.tx, AfterTimeLock).size>0
				            if (hasCheckTimeLockVerify)
				            	txInput.sequenceNumber = TransactionInput.NO_SEQUENCE-1
			            }
			            else {
			            	txInput = new TransactionInput(netParams, tx, input.compileInput(ctx).program)
			            }

			            tx.addInput(txInput)
			        }
			        
			        for (output : body.outputs) {
				        ctx.clear()
			            var value = Coin.valueOf(output.value.exp.interpret.first as Integer)
			            var txOutput = new TransactionOutput(netParams, tx, value, output.compileOutput(ctx).program)
			            tx.addOutput(txOutput)
			        }
			        
			        // set locktime
			        if (body.tlock!==null && body.tlock.containsAbsolute)
				        tx.lockTime = body.tlock.getAbsolute()
			        
			        // set all the signatures within the input scripts (which are never part of the signature)
			        for (var i=0; i<tx.inputs.size; i++) {
			            var txInput = tx.getInput(i)
			            var signatures = ctx.signTracker.get(body.inputs.get(i))
			            
			            if (signatures!==null) {
			            	
			                var outScript = 
			                    if (txInput.outpoint.connectedOutput.scriptPubKey.isPayToScriptHash)
			                        txInput.scriptSig.chunks.get(txInput.scriptSig.chunks.size-1).data
			                    else
			                        txInput.outpoint.connectedPubKeyScript
			                
			                for(sign : signatures) {
			                    // compute the signature
			                    var txSignature = tx.calculateSignature(i, sign.key, outScript, sign.hashType, sign.anyoneCanPay)
			                    
			                    // replace the chunk at index sign.index with the signature
			                    var sb = new ScriptBuilder
			                    
			                    for (var j=0; j<txInput.scriptSig.chunks.size; j++) {
			                    	var chunk = txInput.scriptSig.chunks.get(j)
			                    	
			                    	if (j<sign.index || j>sign.index)
			                    		sb.addChunk(chunk) // copy
			                    	else
			                    		sb.data(txSignature.encodeToBitcoin)
			                    }
			                    
			                    txInput.scriptSig = sb.build
			                }
			            }
			            
			        }
       			}
       			
       			SerialTxBody: {
       				/**
				     * Deserialiaze the transaction bytes into a bitcoinj transaction.
				     * We assume the byte string to be valid.
				     */ 
				    var body = stmt.body as SerialTxBody
			    	tx = new Transaction(stmt.networkParams, Utils.HEX.decode(body.bytes))
			    	
			    	cache.put(stmt, tx)
			    	return tx
       			}
       		}
       		
//       	}
        
        // the tx is not ready yet but it will be at the end of the recursive loop
    	return tx
    }
    
        
    

    def Script compileInput(Input stmt, Context ctx) {

		val result = new ScriptBuilder();

        /*
         * Set the current input within the context.
         * It will be used to set the signatures in the input script.
         */
        ctx.signTracker.currentInput=stmt
		
		if (stmt.isPlaceholder) {
 			/*
             * This transaction is like a coinbase transaction.
             * You can put the input you want.
             */
            return result.number(42).build
		}
		else {
	        var outIdx = stmt.txRef.idx
			switch stmt.txRef.tx.body {
				
				/*
				 * User defined transaction.
				 * Return the expected inputs based on the kind of output script
				 */
				UserDefinedTxBody: {
					var inputTx = stmt.txRef.tx.body as UserDefinedTxBody       
		            var output = inputTx.outputs.get(outIdx);
		    
		            if (output.script.isP2PKH) {
		                var sig = stmt.exps.get(0).simplifySafe as Signature
		                var pubkey = sig.key.body.pvt.value.privateKeyToPubkeyBytes(stmt.networkParams)
		                

		                sig.compileInputExpression(ctx)
		                result.data(pubkey)
		    
		                /* <sig> <pubkey> */
		                result.build
		            } else if (output.script.isP2SH) {
		                
			            if (!result.build.chunks.isEmpty)
			        		throw new CompileException("ScriptBuilder must be empty. It is ["+result.build+"]")
		                
		                // build the list of expression pushes (actual parameters) 
		                stmt.exps.forEach[e|e.simplifySafe.compileInputExpression(ctx)]
		                
		                // get the redeem script to push
		                var redeemScript = output.script.compile(ctx, new Method("???", Void)).output.left
		                
		                result.data(redeemScript.program)
		                                
		                /* <e1> ... <en> <serialized script> */
		                result.build
		            } else
		                throw new CompileException
	            }
	            
				/*
				 * Serialized transaction.
				 * Return the expected inputs based on the kind of output script
				 */
	            SerialTxBody: {
	            	var output = stmt.txRef.tx.toTransaction.getOutput(outIdx)
	            
		            if (output.scriptPubKey.isSentToAddress) {
		                var sig = (stmt.exps.get(0) as Expression).simplifySafe as Signature
		                var pubkey = sig.key.body.pvt.value.privateKeyToPubkeyBytes(stmt.networkParams)
		                
		                sig.compileInputExpression(ctx)
		                result.data(pubkey)
		    
		                /* <sig> <pubkey> */
		                result.build
		            } else if (output.scriptPubKey.isPayToScriptHash) {
		                
		                if (!result.build.chunks.isEmpty)
			        		throw new CompileException("ScriptBuilder must be empty.")
		                
		                // build the list of expression pushes (actual parameters) 
		                stmt.exps.forEach[e|e.simplifySafe.compileInputExpression(ctx)]
		                
		                // get the redeem script to push
		                var redeemScript = stmt.redeemScript.compile(ctx, new Method("???", Void)).output.left
		                result.data(redeemScript.program)
		                
		                /* <e1> ... <en> <serialized script> */
		                result.build
		            } else
		                throw new CompileException
	            }
	            default: throw new CompileException("Unexpected class "+stmt.txRef.tx.body.class)
			}			
		}
    }

	/**
	 * Compile an output based on its "type".
	 */
    def private Script compileOutput(Output output, Context ctx) {
		
        var outScript = output.script

        if (outScript.isP2PKH) {
            var versig = outScript.exp.simplifySafe as Versig
            var pk = versig.pubkeys.get(0).body.pub.value.wifToAddress(output.networkParams)

            var script = ScriptBuilder.createOutputScript(pk)

            if (script.scriptType != ScriptType.P2PKH)
                throw new CompileException

            /* OP_DUP OP_HASH160 <pkHash> OP_EQUALVERIFY OP_CHECKSIG */
            script
        } else if (outScript.isP2SH) {
            
            // get the redeem script to serialize
            var redeemScript = output.script.compile(ctx, new Method("???", Void)).output.left
            var script = ScriptBuilder.createP2SHOutputScript(redeemScript)

            if (script.scriptType != ScriptType.P2SH)
                throw new CompileException

            /* OP_HASH160 <script hash-160> OP_EQUAL */
            script
        } else if (outScript.isOpReturn) {
            var c = outScript.exp as StringLiteral
            var script = ScriptBuilder.createOpReturnScript(c.value.bytes)

            if (script.scriptType != ScriptType.NO_TYPE)
                throw new CompileException

            /* OP_RETURN <bytes> */
            script
        } else
            throw new UnsupportedOperationException
    }


	
	/**
	 * Compile an input expression. It must not have free variables
	 */
    def private Script compileInputExpression(Expression exp, Context ctx) {
        var refs = EcoreUtil2.getAllContentsOfType(exp, VariableReference)
        
        if (!refs.empty)
        	throw new CompileException("The given expression must not have free variables.")
        
        if (!ctx.altstack.isEmpty)
        	throw new CompileException("Altstack must be empty.")
        
        return exp.compileToScript(ctx)	// the altstack is used only by VariableReference(s)
    }
    
    
}
