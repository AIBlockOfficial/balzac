
	@Inject private extension IQualifiedNameProvider
    @Inject private extension BitcoinTMTypeSystem typeSystem
	@Inject private extension ExpressionCompiler expressionCompiler
	@Inject private extension ScriptCompiler scriptCompiler
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

        var resourceName = resource.URI.lastSegment.replace(".btm", "")

        for (package : resource.allContents.toIterable.filter(PackageDeclaration)) {

			var packagePath = package.fullyQualifiedName.toString(File.separator) ;

            fsa.generateFile(packagePath + File.separator + "Transactions.java", package.compile)
            
            generateScriptClasses(package, fsa)
        }
    }
    
    def void generateScriptClasses(PackageDeclaration pkg, IFileSystemAccess2 fsa) {
    	
        var packagePath = pkg.fullyQualifiedName.append("script").toString(File.separator) ;
        
        for (UserDefinedTxBody body : EcoreUtil2.eAllOfType(pkg, UserDefinedTxBody)) {
        	
        	val txName = (body.eContainer as TransactionDeclaration).name
			
			for (var i=0; i<body.outputs.size; i++) {
				val output = body.outputs.get(i)
				val className = '''«txName»_outputScript_«i»'''
		        fsa.generateFile(packagePath + File.separator + className+".java", pkg.compileScript(className, output, body.params))
			}        	
        	
        }
        
    }
    
	def String compileScript(PackageDeclaration pkg, String className, Output output, EList<Parameter> txFreeVariables) {
		val scriptFreeVariables = output.script.params
		val freeVariables = txFreeVariables.toSet
		freeVariables.removeAll(scriptFreeVariables)
		
		'''
			package «pkg.fullyQualifiedName.append("script")»;
			
			import org.bitcoinj.core.*;
			import org.bitcoinj.script.*;
			
			import static org.bitcoinj.script.ScriptOpCodes.*;
			
			public class «className» {
				
				public static Script toScript(«freeVariables.map[p|'''«p.paramType.compile» «p.name»'''].join(", ")») {
					ScriptBuilder sb = new ScriptBuilder();
					
					return sb.build()
				}
			}
		'''
    }    
    
    
    def dispatch String compile(EObject obj) {
        throw new CompileException
    }
    
    def dispatch String compile(Declaration obj) {
        ""
    }

	def dispatch String compile(PackageDeclaration pkg) '''
		package «pkg.fullyQualifiedName»;
		
		import org.bitcoinj.core.*;
		
		public class Transactions {
			
			public static final NetworkParameters params = «IF pkg.net!==null && !pkg.net.isTestnet»NetworkParameters.fromID(NetworkParameters.ID_MAINNET)«ELSE»NetworkParameters.fromID(NetworkParameters.ID_TESTNET)«ENDIF»;
			
			«FOR decl : pkg.declarations»
			«decl.compile»
			
			«ENDFOR»
		}
	'''
	
    	
    def dispatch String compile(KeyDeclaration obj) '''
        public static ECKey getKey_«obj.name»_private() {
        	«IF obj.body.pvt.value!==null»
        	return DumpedPrivateKey.fromBase58(params, "«obj.body.pvt.value»").getKey();
        	«ELSE»
        	return null;
        	«ENDIF»
        }
        
        public static Address getKey_«obj.name»_public() {
        	«IF obj.body.pub.value!==null»
        	return Address.fromBase58(params, "«obj.body.pub.value»");
        	«ELSE»
        	return null;
        	«ENDIF»
        }
    '''

    def dispatch String compile(TransactionDeclaration tx) '''
    	public static Transaction getTransaction_«tx.name»«tx.body.compile»
    	
    '''


    def dispatch String compile(SerialTxBody body) '''
		() {
			byte[] payload = Utils.HEX.decode("«body.bytes»");
			return new Transaction(params, payload);
		}
    '''
	
	def dispatch String compile(UserDefinedTxBody body) '''
		(«body.params.map[p|'''«p.paramType.compile» «p.name»'''].join(", ")») {
			
«««			Map<String, Object> freeVariables = new HashMap<>();
«««			Map<String, Class<?>> freeVariablesTypes = new HashMap<>();
«««			«FOR p:body.params»
«««			freeVariables.put("«p.name»", «p.name»);
«««			freeVariablesTypes.put("«p.name»", «p.paramType.compile».class);
«««			«ENDFOR»

			Transaction tx = new Transaction(params);
		
			«FOR i : 0..<body.inputs.size»
			«val input = body.inputs.get(i)»
«««			Transaction txToRedeem = getTransaction_«input.txRef.tx.name»(«input.txRef.actualParams.map[e|e.compileInputExpression()].join(", ")»);
«««			int outIndex_«i» = «input.txRef.idx»;
«««			TransactionOutPoint txOutPoint_«i» = new TransactionOutPoint(params, outIndex, txToRedeem)
«««			TransactionInput txInput_«i» = new TransactionInput(params, tx, );
«««			
«««			tx.addInput(txInput_«i»);
			«ENDFOR»


			«FOR i : 0..<body.outputs.size»
			«val output = body.outputs.get(i)»
			«val context = new Context»
			««« map the actual parameters to the formal one s»»»
«««			Coin value_«i» = Coin.valueOf(«output.value.exp.interpret.first as Integer»);
«««			Script pubScript_«i» = getOutputScript_«(body.eContainer as TransactionDeclaration).name»_«i»();
«««			TransactionOutput txOutput_«i» = new TransactionOutput(params, tx, value_«i», pubScript_«i».getProgram());
«««			tx.addOutput(txOutput_«i»);
			«ENDFOR»
						
			return tx;
		}
    '''
    
    
}
