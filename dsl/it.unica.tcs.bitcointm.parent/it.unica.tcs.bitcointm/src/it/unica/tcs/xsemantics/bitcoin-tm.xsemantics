/*
 * Copyright 2017 Nicola Atzei
 */

import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndScriptExpression
import it.unica.tcs.bitcoinTM.Ask
import it.unica.tcs.bitcoinTM.Assert
import it.unica.tcs.bitcoinTM.BasicType
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Choice
import it.unica.tcs.bitcoinTM.ExpressionI
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.Hash160
import it.unica.tcs.bitcoinTM.Hash160Literal
import it.unica.tcs.bitcoinTM.Hash160Type
import it.unica.tcs.bitcoinTM.Hash256
import it.unica.tcs.bitcoinTM.Hash256Literal
import it.unica.tcs.bitcoinTM.Hash256Type
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrScriptExpression
import it.unica.tcs.bitcoinTM.Output
import it.unica.tcs.bitcoinTM.Parallel
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.ParticipantDeclaration
import it.unica.tcs.bitcoinTM.ProcessDeclaration
import it.unica.tcs.bitcoinTM.ProcessReference
import it.unica.tcs.bitcoinTM.ProtocolIfThenElse
import it.unica.tcs.bitcoinTM.ProtocolTransactionReference
import it.unica.tcs.bitcoinTM.Put
import it.unica.tcs.bitcoinTM.Receive
import it.unica.tcs.bitcoinTM.Ripemd160
import it.unica.tcs.bitcoinTM.Ripemd160Literal
import it.unica.tcs.bitcoinTM.Ripemd160Type
import it.unica.tcs.bitcoinTM.ScriptArithmeticSigned
import it.unica.tcs.bitcoinTM.ScriptBooleanNegation
import it.unica.tcs.bitcoinTM.ScriptComparison
import it.unica.tcs.bitcoinTM.ScriptEquals
import it.unica.tcs.bitcoinTM.ScriptMinus
import it.unica.tcs.bitcoinTM.ScriptPlus
import it.unica.tcs.bitcoinTM.Send
import it.unica.tcs.bitcoinTM.SerialTransactionDeclaration
import it.unica.tcs.bitcoinTM.Sha256
import it.unica.tcs.bitcoinTM.Sha256Literal
import it.unica.tcs.bitcoinTM.Sha256Type
import it.unica.tcs.bitcoinTM.SignOp
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Tau
import it.unica.tcs.bitcoinTM.TransactionBody
import it.unica.tcs.bitcoinTM.TransactionDeclaration
import it.unica.tcs.bitcoinTM.TransactionType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.TypeVariable
import it.unica.tcs.bitcoinTM.Typeable
import it.unica.tcs.bitcoinTM.UserTransactionDeclaration
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.bitcoinTM.VersigOp
import it.unica.tcs.lib.utils.BitcoinUtils
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import java.math.BigInteger
import java.util.Map
import org.bitcoinj.core.Utils
import org.eclipse.emf.ecore.util.EcoreUtil

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

inject LambdaUtils lambdaUtils

auxiliary {
	notoccur(Type type, Type other)
        error stringRep(type) + " occurs in " + stringRep(other)
        
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    
    unify(TypeSubstitutions substitutions, Type left, Type right) : Type
        error "Cannot unify " + stringRep(left) + " with " + stringRep(right)
        
}

judgments {

	type |- TypeSubstitutions substitutions |> Typeable exp : output Type
		error "Cannot type " + stringRep(exp)
		source exp
		
	interpret |- ExpressionI expression |> Map<Parameter,Object> rho ~> output Object
	simplify  |= ExpressionI expression ~> output ExpressionI
}

/*
 * auxiliary functions
 */

auxiliary notoccur(Type type, Type other) { true }

auxiliary notoccur(TypeVariable variable, TypeVariable other) {
    variable.value != other.value
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(TypeSubstitutions substitutions, Type t1, Type t2) {
    // if we get here we cannot unify the two types
    fail
	error "Cannot unify type "+t1+" with type "+t2
	null
} 

auxiliary unify(TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash160Type t1, Hash160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash256Type t1, Hash256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Ripemd160Type t1, Ripemd160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Sha256Type t1, Sha256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash256Type t1, Sha256Type t2) {
    unify(substitutions,t2,t1)
}

auxiliary unify(TypeSubstitutions substitutions, Sha256Type t1, Hash256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash160Type t1, Ripemd160Type t2) {
    unify(substitutions,t2,t1)
}

auxiliary unify(TypeSubstitutions substitutions, Ripemd160Type t1, Hash160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, TransactionType t1, TransactionType t2) {
    EcoreUtil::copy(t1)
}


auxiliary unify(TypeSubstitutions substitutions, TypeVariable typeVar, BasicType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(TypeSubstitutions substitutions, BasicType basicType, TypeVariable typeVar) {
    unify(substitutions, typeVar, basicType)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}



/*
 * Type system rules
 */

rule SerialTransactionDeclaration
	G |- TypeSubstitutions substitutions |> SerialTransactionDeclaration tx : Type t
from {}

/**
 * Type check a user defined transactions:
 * - all the parameters are well typed and the type is basic (not generic)
 */
rule UserTransactionDeclaration
	G |- TypeSubstitutions substitutions |> UserTransactionDeclaration tx : Type t
from {
	
	for (p : tx.params) {
		G |- substitutions |> p : var Type paramType
		G.add(p, paramType)			// store the type in the environment
		p.paramType = paramType		// and in the AST
	}
	
	// transaction body is well typed
	G |- substitutions |> tx.body : var Type t1
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : tx.params) {
		p.paramType = typesubstitution(substitutions, p.paramType)
		{p.paramType instanceof BasicType}
	}
}

/*
 * - all the inputs are well typed
 * - all the outputs are well typed
 */
rule TransactionBody
	G |- TypeSubstitutions substitutions |> TransactionBody body : Type t
from {
	
	for (in : body.inputs) {
		G |- substitutions |> in : var Type t1	// all inputs are well typed
	}
	
	for (out : body.outputs) {
		G |- substitutions |> out : var Type t2	// all outputs are well typed
	}
}


/**
 * An input is well typed if:
 * - the body of the redeemed transaction is well typed
 * - all the expressions are well typed and the type is basic (not generic)
 * - if the redeemed tx has free variables, check that the actual types corresponds to the formal ones 
 * - if the redeemed tx is user defined, all the expression type corresponds to the expected type of the parameter
 */
rule Input
	G |- TypeSubstitutions substitutions |> Input input : Type t
from {
	
	if (!input.isPlaceholder) {		
		// the body of the redeemed transaction is well typed
		var inputTx = input.txRef.tx
		G |- substitutions |> inputTx : var Type t1		// eventual tx parameters have type BasicType
	
		// all the input expressions are well typed and the type is basic
		for (var i=0; i<input.exps.size; i++) {
			var exp = input.exps.get(i)
			
			if (inputTx instanceof UserTransactionDeclaration) {
				G |- substitutions |> exp : var Type texp	// type can be inferred by the "invocation" of inputTx
				G.add(exp,texp)		// store the type for further checks (see below)
			}
			else {
				G |- substitutions |> exp : var BasicType texp
			}
		}
	
		if (inputTx instanceof UserTransactionDeclaration) {
			
			// check the actual parameters type match the formal ones (Transaction)
			for (var i=0; i<input.txRef.actualParams.size; i++) {
				var actualParam = input.txRef.actualParams.get(i)
				var formalParam = inputTx.params.get(i)
				
				{formalParam.paramType instanceof BasicType}	// true by rule for UserTransactionDeclaration
				
				// all the actual parameters are well typed and the type is basic
				G |- substitutions |> actualParam : var Type actualParamType
				
				// the actual param type must be unifiable with the formal param type
				unify(substitutions, actualParamType, formalParam.paramType)
			}
			
			// check the actual parameters type match the formal ones (Script)
			var outputIndex = input.outpoint
			var outputScript = inputTx.body.outputs.get(outputIndex).script
			for (var i=0; i<input.exps.size; i++) {
				var inputExp = input.exps.get(i)
				var outputParam = outputScript.params.get(i)
				
				var inputExpType = G.get(inputExp) as Type		// retrieve the type from G
				var outputParamType = outputParam.paramType 
				
				G.decrement(inputExp)					// remove the type from G
				
				// the actual param type must be unifiable with the formal param type
				unify(substitutions, inputExpType, outputParamType)
			}
		}
	}
}

/**
 * An Output is well typed if:
 * - all the scripts parameters are well typed and the type is basic (not generic)
 * - all the scripts expressions are well typed
 */
rule Output
	G |- TypeSubstitutions substitutions |> Output _output : Type t
from {
	var satoshis = _output.value.exp
	G |- new TypeSubstitutions() |> satoshis : var IntType intType
	
	var script = _output.script
	for (p : script.params) {
		G |- substitutions |> p : var Type paramType
		G.add(p, paramType)			// store the type in the environment
		p.paramType = paramType		// and in the AST
	}

	val int value = interpret(satoshis, newHashMap).first as Integer
	
	var expectedType = 
		if (value==0) {
			BitcoinTMFactory::eINSTANCE.createStringType
		}
		else {
			BitcoinTMFactory::eINSTANCE.createBooleanType
		}
	
	G |- substitutions |> script.exp : expectedType // shouldn't be boolean?
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : script.params) {
		p.paramType = typesubstitution(substitutions, p.paramType)
		{p.paramType instanceof BasicType}
	}
}


rule Parameter
	G |- TypeSubstitutions substitutions |> Parameter p : Type type
from {
	{
		p.paramType !== null
		type = EcoreUtil.copy(p.paramType)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
}

/*
 * Expressions type system
 */
axiom NumeralLiteral
	G |- TypeSubstitutions substitutions |> NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- TypeSubstitutions substitutions |> StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Hash160Literal
	G |- TypeSubstitutions substitutions |> Hash160Literal h : BitcoinTMFactory::eINSTANCE.createHash160Type

axiom Hash256Literal
	G |- TypeSubstitutions substitutions |> Hash256Literal h : BitcoinTMFactory::eINSTANCE.createHash256Type

axiom Ripemd160Literal
	G |- TypeSubstitutions substitutions |> Ripemd160Literal h : BitcoinTMFactory::eINSTANCE.createRipemd160Type

axiom Sha256Literal
	G |- TypeSubstitutions substitutions |> Sha256Literal h : BitcoinTMFactory::eINSTANCE.createSha256Type

axiom Signature
	G |- TypeSubstitutions substitutions |> Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType


rule VariableReference
	G |- TypeSubstitutions substitutions |> VariableReference varRef : Type type
from {
	type = typesubstitution(substitutions, EcoreUtil.copy(env(G, varRef.ref, Type)))
	varRef.ref.paramType = EcoreUtil.copy(type)	// set the param type, useful just for the ui
}

rule Minus
	G |- TypeSubstitutions substitutions |> ScriptMinus minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> ScriptPlus plus : Type type
from {
    G |- substitutions |> plus.left : var Type leftType
    G |- substitutions |> plus.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
    {
    	type = BitcoinTMFactory::eINSTANCE.createStringType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
	}
    or
    {
       	type = BitcoinTMFactory::eINSTANCE.createIntType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
    }
}

rule Comparison
	G |- TypeSubstitutions substitutions |> ScriptComparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Equals
	G |- TypeSubstitutions substitutions |> ScriptEquals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// equals between elements of the same type
	unify(substitutions, leftType, rightType)
}

rule BooleanNegation
	G |- TypeSubstitutions substitutions |> ScriptBooleanNegation negation : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> negation.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, boolType)
}

rule Or
	G |- TypeSubstitutions substitutions |> OrScriptExpression orExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> orExp.left : var Type leftType
	G |- substitutions |> orExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule And
	G |- TypeSubstitutions substitutions |> AndScriptExpression andExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> andExp.left : var Type leftType
	G |- substitutions |> andExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule ArithmeticSigned
	G |- TypeSubstitutions substitutions |> ScriptArithmeticSigned signed : IntType intType
from {
	intType = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> signed.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, intType)
}

rule IfThenElse
	G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
	var boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> stmt.^if: var Type tIf
	G |- substitutions |> stmt.then: var Type tThen
	
	tIf = typesubstitution(substitutions, tIf)
	tThen = typesubstitution(substitutions, tThen)
	
	unify(substitutions, tIf, boolType)

	G |- substitutions |> stmt.^else: var Type tElse
	tElse = typesubstitution(substitutions, tElse)
	unify(substitutions, tThen, tElse)
	
	type=tThen
}

rule VerSig
	G |- TypeSubstitutions substitutions |> Versig versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, sigType)
	}
}

rule Hash160
	G |- TypeSubstitutions substitutions |> Hash160 hash: BitcoinTMFactory::eINSTANCE.createHash160Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Hash256
	G |- TypeSubstitutions substitutions |> Hash256 hash: BitcoinTMFactory::eINSTANCE.createHash256Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Ripemd160
	G |- TypeSubstitutions substitutions |> Ripemd160 hash: BitcoinTMFactory::eINSTANCE.createRipemd160Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Sha256
	G |- TypeSubstitutions substitutions |> Sha256 hash: BitcoinTMFactory::eINSTANCE.createSha256Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Min
	G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> min.left: var Type tleft
	G |- substitutions |> min.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Max
	G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> max.left: var Type tleft
	G |- substitutions |> max.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Between
	G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> between.value: var Type tValue
	G |- substitutions |> between.left: var Type tLeft
	G |- substitutions |> between.right: var Type tRight
	
	tValue = typesubstitution(substitutions, tValue)
	tLeft = typesubstitution(substitutions, tLeft)
	tRight = typesubstitution(substitutions, tRight)
	
	unify(substitutions, tValue, t)
	unify(substitutions, tLeft, t)
	unify(substitutions, tRight, t)
}

rule Size
	G |- TypeSubstitutions substitutions |> Size size: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> size.value: var Type t
	
	t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
	G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
	G |- substitutions |> after.continuation: texpr
	texpr = typesubstitution(substitutions, texpr)
}

/*
 * Protocols/Processes
 */
rule ParticipantDeclaration
	G |- TypeSubstitutions substitutions |> ParticipantDeclaration p : Type t
from {
	for (d : p.defs) {
		G |- substitutions |> d : t	
	}
	
	G |- substitutions |> p.process : t
}

rule ProcessDeclaration
	G |- TypeSubstitutions substitutions |> ProcessDeclaration p : Type t
from {
	for (param : p.params) {
		G |- substitutions |> param : var Type paramType
		G.add(param, paramType)			// store the type in the environment 
		param.paramType = paramType		// and in the AST
	}

	// process is well typed
	G |- substitutions |> p.process : t
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (param : p.params) {
		param.paramType = typesubstitution(substitutions, param.paramType)
		{param.paramType instanceof BasicType}
	}
}
 
rule Choice
	G |- TypeSubstitutions substitutions |> Choice choice : Type type
from {
	for (a : choice.actions) {
		G |- substitutions |> a : var Type t
		if (a.next!==null) {
			G |- substitutions |> a.next : var Type t1
		}
	}
}

rule Parallel
	G |- TypeSubstitutions substitutions |> Parallel p : Type type
from {
	G |- substitutions |> p.left : var Type t
	G |- substitutions |> p.right : var Type t1
}

rule ProcessReference
	G |- TypeSubstitutions substitutions |> ProcessReference pRef : Type type
from {
	// check the actual parameters type match the formal ones (Transaction)
	for (var i=0; i<pRef.actualParams.size; i++) {
		var actualParam = pRef.actualParams.get(i)
		var formalParam = pRef.ref.params.get(i)

		// all the actual parameters are well type and the type is basic
		G |- substitutions |> actualParam : var Type actualParamType

		println(actualParamType)
		println(formalParam.paramType)
		
		// the actual param type must be unifiable with the formal param type
		unify(substitutions, actualParamType, formalParam.paramType)
	}
}

rule ProtocolIfThenElse
	G |- TypeSubstitutions substitutions |> ProtocolIfThenElse ifThenElse : Type type
from {
	G |- substitutions |> ifThenElse.exp : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createBooleanType)
	
	G |- substitutions |> ifThenElse.^then : var Type t1
	if (ifThenElse.^else!==null) {
		G |- substitutions |> ifThenElse.^else : var Type t2
	}
}

rule Tau
	G |- TypeSubstitutions substitutions |> Tau tau : Type type
from {}

rule Ask
	G |- TypeSubstitutions substitutions |> Ask ask : Type type
from {
	for (txRef : ask.txRefs) {
		G |- substitutions |> txRef : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createTransactionType)
	}
}

rule Put
	G |- TypeSubstitutions substitutions |> Put put : Type type
from {
	for (txRef : put.txRefs) {
		G |- substitutions |> txRef : var Type t
	}
}

rule Assert
	G |- TypeSubstitutions substitutions |> Assert a : Type type
from {
	G |- substitutions |> a.exp : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createBooleanType)
}

rule Send
	G |- TypeSubstitutions substitutions |> Send send : Type type
from {
	G |- substitutions |> send.message : var BasicType t
}

rule Receive
	G |- TypeSubstitutions substitutions |> Receive receive : Type type
from {
	G |- substitutions |> receive.^var : var BasicType t
}


/*
 * ProtocolExpressions
 */
rule SignOp
    G |- TypeSubstitutions substitutions |> SignOp sig : BitcoinTMFactory::eINSTANCE.createSignatureType
from {
	G |- substitutions |> sig.tx : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createTransactionType)
}

rule VersigOp	// same as before, but check for transaction to be well-typed
	G |- TypeSubstitutions substitutions |> VersigOp versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> versig.tx : var TransactionType t
	
	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type t1
		t1 = typesubstitution(substitutions, t1)
		unify(substitutions, t1, sigType)
	}
}

rule ProtocolTransactionReference
    G |- TypeSubstitutions substitutions |> ProtocolTransactionReference txRef : BitcoinTMFactory::eINSTANCE.createTransactionType
from {
	if (txRef.substitution!==null) {
		G |- substitutions |> txRef.substitution: var Type t1
	}
}


/*
 * 
 * Expression Interpreter
 * 
 */

rule InterpretVariableReference
	G |- VariableReference v |> Map<Parameter, Object> rho ~> Object res
from {
	{rho.containsKey(v.ref)}
	res = rho.get(v.ref)
}
  
axiom InterpretNumberLiteral
    G |- NumberLiteral number |> Map<Parameter, Object> rho ~> number.value

axiom InterpretStringLiteral
    G |- StringLiteral str |> Map<Parameter,Object> rho ~> str.value

axiom InterpretBooleanLiteral
    G |- BooleanLiteral bool |> Map<Parameter,Object> rho ~> bool.^true

axiom InterpretHash160Literal
    G |- Hash160Literal hash |> Map<Parameter,Object> rho ~> new it.unica.tcs.lib.Hash.Hash160(hash.value)

axiom InterpretHash256Literal
    G |- Hash256Literal hash |> Map<Parameter,Object> rho ~> new it.unica.tcs.lib.Hash.Hash256(hash.value)

axiom InterpretRipemd160Literal
    G |- Ripemd160Literal hash |> Map<Parameter,Object> rho ~> new it.unica.tcs.lib.Hash.Ripemd160(hash.value)

axiom InterpretSha256Literal
    G |- Sha256Literal hash |> Map<Parameter,Object> rho ~> new it.unica.tcs.lib.Hash.Sha256(hash.value)

rule InterpretMinus
    G |- ScriptMinus minus |> Map<Parameter,Object> rho ~> Integer result
from {
    G |- minus.left |> rho ~> var Integer leftResult
    G |- minus.right |> rho ~> var Integer rightResult
    result = leftResult.intValue - rightResult.intValue
}

rule InterpretPlus
    G |- ScriptPlus plus |> Map<Parameter,Object> rho ~> Object result
from {
    G |- plus.left |> rho ~> var Object leftResult
    G |- plus.right |> rho ~> var Object rightResult
    
    if (leftResult instanceof String || rightResult instanceof String) {
        var leftString = leftResult.toString
        var rightString = rightResult.toString
        result = leftString + rightString
    } else {
        // both are int if the expression is well-typed
        var leftInt = leftResult as Integer
        var rightInt = rightResult as Integer
        result = leftInt + rightInt
    }
}

rule InterpretArithmeticSigned
    G |- ScriptArithmeticSigned signed |> Map<Parameter,Object> rho ~> Integer result
from {
    G |- signed.exp |> rho ~> var Integer expResult
    result = -(expResult)
}

rule InterpretAnd
    G |- AndScriptExpression and |> Map<Parameter,Object> rho ~> Boolean result
from {
    G |- and.left |> rho ~> var Boolean leftResult
    
    if (leftResult == false) {
    	result = false
    }
    else {
	    G |- and.right |> rho ~> var Boolean rightResult
	    result = leftResult.booleanValue && rightResult.booleanValue    	
    }    
}

rule InterpretOr
    G |- OrScriptExpression orExp |> Map<Parameter,Object> rho ~> Boolean result
from {
    G |- orExp.left |> rho ~> var Boolean leftResult
    
    if (leftResult == true) {
    	result = true
    }
    else {
	    G |- orExp.right |> rho ~> var Boolean rightResult
	    result = leftResult.booleanValue || rightResult.booleanValue 
    }    
}

rule InterpretBooleanNegation
    G |- ScriptBooleanNegation neg |> Map<Parameter,Object> rho ~> Boolean result
from {
    G |- neg.exp |> rho ~> var Boolean expResult
    result = !expResult
}

rule InterpretComparison
    G |- ScriptComparison comparison |> Map<Parameter,Object> rho ~> Boolean result
from {
    G |- comparison.left |> rho ~> var Comparable<Object> leftResult
    G |- comparison.right |> rho ~> var Object rightResult
    
    result = switch(comparison.op) {
    		case ">=": leftResult >= rightResult
    		case "<=": leftResult <= rightResult
    		case ">": leftResult > rightResult
    		case "<": leftResult < rightResult
    		default: null
    	}
    	
	if (result===null) {
		fail 
			error "Unexpecter operator "+comparison.op 
			source comparison
	}
}

rule InterpretEquals
    G |- ScriptEquals comparison |> Map<Parameter,Object> rho ~> Boolean result
from {
	
	{
	    G |- comparison.left |> rho ~> var Object leftResult
	    G |- comparison.right |> rho ~> var Object rightResult
	    
	    var areEqual = leftResult==rightResult
	    
	    result = switch(comparison.op) {
    		case "==": areEqual
    		case "!=": !areEqual
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpected operator "+comparison.op 
				source comparison
		}
	    
    } or {
    	// TODO: remove this case
    	comparison.left instanceof Signature
    	comparison.right instanceof Signature
    	// two signs are the same if the key and the modifier are the same
    	(comparison.left as Signature).key == (comparison.right as Signature).key;
    	(comparison.left as Signature).modifier == (comparison.right as Signature).modifier;
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    } or {
    	comparison.left instanceof VariableReference
    	comparison.right instanceof VariableReference
		// two refs are the same if they point to the same parameter
    	var leftResult = (comparison.left as VariableReference).ref 
    	var rightResult = (comparison.right as VariableReference).ref
    	leftResult == rightResult
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    }    
}

rule InterpretIfThenElse
    G |- IfThenElse stmt |> Map<Parameter,Object> rho ~> Object result
from {
    G |- stmt.^if |> rho ~> var Boolean ifCondition
    
    if (ifCondition) {
        G |- stmt.then |> rho ~> var Object thenResult
        result = thenResult
    }
    else {
        G |- stmt.^else |> rho ~> var Object elseResult
        result = elseResult
    }
}

rule InterpretMin
    G |- Min stmt |> Map<Parameter,Object> rho ~> Integer result
from {
    G |- stmt.left |> rho ~> var Integer leftRes
    G |- stmt.right |> rho ~> var Integer rightRes
    
    if (leftRes<=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretMax
    G |- Max stmt |> Map<Parameter,Object> rho ~> Integer result
from {
    G |- stmt.left |> rho ~> var Integer leftRes
    G |- stmt.right |> rho ~> var Integer rightRes
    
    if (leftRes>=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretBetween
    G |- Between stmt |> Map<Parameter,Object> rho ~> Boolean result
from {
    G |- stmt.value |> rho ~> var Integer valueRes
    G |- stmt.left |> rho ~> var Integer leftRes
    G |- stmt.right |> rho ~> var Integer rightRes
    result = leftRes<=valueRes && valueRes<rightRes
}

rule InterpretHash
    G |- Hash hash |> Map<Parameter,Object> rho ~> it.unica.tcs.lib.Hash result
from {

    G |- hash.value |> rho ~> var Object expResult
    
    // hash the bytes
    if (hash instanceof Hash160)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Hash160)
    else if (hash instanceof Hash256)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Hash256)
    else if (hash instanceof Ripemd160)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Ripemd160)
    else if (hash instanceof Sha256)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Sha256)
	else {
		fail 
		error "Unexpecter instance "+hash.class 
		source hash
	}
}

rule InterpretSize
    G |- Size size |> Map<Parameter,Object> rho ~> Integer result
from {
	G |- size.value |> rho ~> var Integer res
	
	if (res==0) 
		result=0
	else {
		// ⌈(log2 |n| / 7)⌉
		result = Utils.encodeMPI(BigInteger.valueOf(res), false).length
	}
}


/*
 * AST simplifier (TODO)
 */
axiom SimplifyExpressionI
	G |= ExpressionI obj ~> obj
	
//rule SimplifyAnd
//    G |= AndExpression exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Boolean leftResult
//	    {leftResult == true}	    
//	    G |= exp.right ~> result
//	} or {
//	    G |- exp.right ~> var Boolean rightResult
//	    {rightResult == true}	    
//	    G |= exp.left ~> result
//	} or {
//		var newExp = BitcoinTMFactory::eINSTANCE.createAndExpression
//		newExp.left = simplifySafe(exp.left)
//		newExp.right = simplifySafe(exp.right)
//	}
//}
//
//rule SimplifyOr
//    G |= OrExpression exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Boolean leftResult
//	    {leftResult == false}	    
//	    G |= exp.right ~> result
//	} or {
//	    G |- exp.right ~> var Boolean rightResult
//	    {rightResult == false}	    
//	    G |= exp.left ~> result
//	} or {
//		exp.left = simplifySafe(exp.left)
//		exp.right = simplifySafe(exp.right)
//	}
//}
//
//rule SimplifyPlus
//    G |= Plus exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Integer leftResult
//	    {leftResult == 0}
//	    G |= exp.right ~> result    
//	} or {
//	    G |- exp.right ~> var Integer rightResult
//	    {rightResult == 0}	    
//	    G |= exp.left ~> result
//	} or {
//		exp.left = simplifySafe(exp.left)
//		exp.right = simplifySafe(exp.right)
//	}
//}
//
//rule SimplifyMinus
//    G |= Minus exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Integer leftResult
//	    {leftResult == 0}	    
//	    G |= exp.right ~> result
//	} or {
//	    G |- exp.right ~> var Integer rightResult
//	    {rightResult == 0}	    
//	    G |= exp.left ~> result
//	} or {
//		exp.left = simplifySafe(exp.left)
//		exp.right = simplifySafe(exp.right)
//	}
//}

/*
 * 
 * rule invocations
 * 
 */
checkrule CheckTransactionDeclaration for
    TransactionDeclaration stmt
from {
	lambdaUtils.resetCounter
    empty |- new TypeSubstitutions |> stmt: var Type t
}

checkrule CheckParticipantDeclaration for
    ParticipantDeclaration stmt
from {
	lambdaUtils.resetCounter
    empty |- new TypeSubstitutions |> stmt: var Type t
}
