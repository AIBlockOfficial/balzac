import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.validation.AbstractBitcoinTMValidator

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

judgments {

	type |- Expression expression : output Type
		error "cannot type " + stringRep(expression)
		source expression
		
	vartype ||- Parameter p : output Type
		error "cannot type " + stringRep(p)
		source p
//		
//	validate |= EObject obj
//		error "cannot type " + stringRep(obj)
//		source obj
	
//	interpret |- Expression expression ~> output Object
}


/*
 * expressions
 */

axiom NumeralLiteral
	G |- NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Signature
	G |- Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType

rule VariableReference
	G |- VariableReference varRef : Type type
from {
	G ||- varRef.ref : type
}

rule Parameter
	G ||- Parameter p : Type type
from {
	type = p.paramType
}


rule Minus
	G |- Minus minus : IntType t
from {
	G |- minus.left : t
	G |- minus.right : t
}

rule Plus
    G |- Plus plus : Type type
from {
    G |- plus.left : var Type leftType
    G |- plus.right : var Type rightType
    
    {
        (leftType instanceof StringType && rightType instanceof StringType)
        type = BitcoinTMFactory::eINSTANCE.createStringType
    }
    or
    {
        (leftType instanceof IntType && rightType instanceof IntType)
        type = leftType // i.e., IntType
    }
}

rule Comparison
	G |- Comparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var IntType intType
	G |- comparison.left : intType
	G |- comparison.right : intType
}

rule Equals
	G |- Equals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- comparison.left : var Type leftType
	G |- comparison.right : var Type rightType
	
	// can compare only if they have the same type
	(leftType.eClass == rightType.eClass)
}

rule BooleanNegation
	G |- BooleanNegation negation : BooleanType boolType
from {
	G |- negation.exp : boolType
}

rule Or
	G |- OrExpression orExp : BooleanType boolType
from {
	G |- orExp.left : boolType
	G |- orExp.right : boolType
}

rule And
	G |- AndExpression andExp : BooleanType boolType
from {
	G |- andExp.left : boolType
	G |- andExp.right : boolType
}

rule ArithmeticSigned
	G |- ArithmeticSigned signed : IntType intType
from {
	G |- signed.exp : intType
}

rule IfThenElse
	G |- IfThenElse stmt : Type type
from {
	G |- stmt.^if: var BooleanType tIf
	G |- stmt.then: var Type tThen
	G |- stmt.^else: var Type tElse
}

rule VerSig
	G |- Versig versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	for (s : versig.signatures) {
		G |- s : var SignatureType t
	}	
}

rule Hash
	G |- Hash hash: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- hash.value: var Type t
}

rule Min
	G |- Min min: IntType t
from {
	G |- min.left: t
	G |- min.right: t
}

rule Max
	G |- Max max: IntType t
from {
	G |- max.left: t
	G |- max.right: t
}

rule Between
	G |- Between between: IntType t
from {
	G |- between.value: t
	G |- between.left: t
	G |- between.right: t
}

rule Size
	G |- Size size: IntType t
from {
	G |- size.value: t
}

rule AfterTimeLock
	G |- AfterTimeLock after: Type texpr
from {
	G |- after.time: var IntType tvalue
	G |- after.continuation: texpr
}


/*
 * rule invocations
 */
checkrule CheckExpression for
    Expression expr
from {
    empty |- expr : var Type type
}

checkrule CheckParameter for
    Parameter p
from {
    empty ||- p : var Type type
}

