import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.validation.AbstractBitcoinTMValidator

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

judgments {

	type |- Expression expression : output Type
		error "cannot type " + stringRep(expression)
		source expression
		
	vartype ||- Parameter p : output Type
//		error "cannot type " + stringRep(fn)
//		source fn
//		
//	validate |= EObject obj
//		error "cannot type " + stringRep(obj)
//		source obj
	
//	interpret |- Expression expression ~> output Object
}


/*
 * expressions
 */

axiom NumeralLiteral
	G |- NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Signature
	G |- Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType

rule VariableReference
	G |- VariableReference varRef : Type type
from {
	G ||- varRef.ref : type
}

rule Parameter
	G ||- Parameter p : Type type
from {
	type = p.paramType
}


rule Minus
	G |- Minus minus : IntType type
from {
	var IntType intType
	G |- minus.left : intType
	G |- minus.right : intType
}

rule Plus
    G |- Plus plus : Type type
from {
    G |- plus.left : var Type leftType
    G |- plus.right : var Type rightType
    
    {
        (leftType instanceof StringType && rightType instanceof StringType)
        type = BitcoinTMFactory::eINSTANCE.createStringType
    }
    or
    {
        (leftType instanceof IntType && rightType instanceof IntType)
        type = leftType // i.e., IntType
    }
}

rule Comparison
	G |- Comparison comparison : BooleanType type
from {
	var IntType intType
	G |- comparison.left : intType
	G |- comparison.right : intType
}

rule Equals
	G |- Equals comparison : BooleanType type
from {
	G |- comparison.left : var Type leftType
	G |- comparison.right : var Type rightType
	
	// can compare only if they have the same type
	(leftType.eClass == rightType.eClass)
}

rule BooleanNegation
	G |- BooleanNegation negation : BooleanType boolType
from {
	G |- negation.exp : boolType
}

rule Or
	G |- OrExpression orExp : BooleanType boolType
from {
	G |- orExp.left : boolType
	G |- orExp.right : boolType
}

rule And
	G |- AndExpression andExp : BooleanType boolType
from {
	G |- andExp.left : boolType
	G |- andExp.right : boolType
}

rule ArithmeticSigned
	G |- ArithmeticSigned signed : IntType intType
from {
	G |- signed.exp : intType
}

rule IfThenElse
	G |- IfThenElse stmt : Type type
from {
	G |- stmt.^if: var BooleanType tIf
	G |- stmt.then: var Type tThen
	G |- stmt.^else: var Type tElse
}

rule VerSig
	G |- Versig versig : BooleanType type
from {
	for (s : versig.signatures) {
		G |- s : var SignatureType t
	}	
}

rule Hash
	G |- Hash hash: IntType intType
from {
	G |- hash.value: var Type t
}

rule Min
	G |- Min min: IntType intType
from {
	G |- min.left: var IntType tleft
	G |- min.right: var IntType tright
}

rule Max
	G |- Max max: IntType intType
from {
	G |- max.left: var IntType tleft
	G |- max.right: var IntType tright
}

rule Between
	G |- Between between: BooleanType t
from {
	G |- between.value: var IntType tvalue
	G |- between.left: var IntType tleft
	G |- between.right: var IntType tright
}

rule Size
	G |- Size size: IntType intType
from {
	G |- size.value: var IntType tvalue
}

rule AfterTimeLock
	G |- AfterTimeLock after: Type t
from {
	G |- after.time: var IntType tvalue
	G |- after.continuation: var Type texpr
}


/*
 * rule invocations
 */
checkrule CheckExpression for
    Expression expr
from {
    empty |- expr : var Type type
}


