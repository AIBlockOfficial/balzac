import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.BasicType
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BitcoinValue
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.HashType
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Script
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.TypeVariable
import it.unica.tcs.bitcoinTM.UserDefinedTxBody
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import org.eclipse.emf.ecore.util.EcoreUtil

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

inject LambdaUtils lambdaUtils


auxiliary {
	notoccur(Type type, Type other)
        error stringRep(type) + " occurs in " + stringRep(other)
        
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    
    unify(TypeSubstitutions substitutions, Type left, Type right) : Type
        error "Cannot unify " + stringRep(left) + " with " + stringRep(right)
        
    simplifySafe(Expression exp) : Expression
}

judgments {

	scriptType |~ Script s
		error "Cannot type " + stringRep(s)
		source s
	
	witscriptType ||~ Input s
		error "Cannot type " + stringRep(s)
		source s
	
	bitValueType |= BitcoinValue v
		error "Cannot type " + stringRep(v)
		source v

	type |- TypeSubstitutions substitutions |> Expression exp : output Type
		error "Cannot type " + stringRep(exp)
		source exp
		
	vartype ||- Parameter p : output Type
		error "Cannot type " + stringRep(p)
		source p
	
//		
//	validate |= EObject obj
//		error "cannot type " + stringRep(obj)
//		source obj
	
	interpret |- Expression expression ~> output Object
	
	simplify |= Expression obj ~> output Expression
}

/*
 * auxiliary functions
 */

auxiliary notoccur(Type type, Type other) { true }

auxiliary notoccur(TypeVariable variable, TypeVariable other) {
    variable.value != other.value
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(TypeSubstitutions substitutions, Type t1, Type t2) {
    // if we get here we cannot unify the two types
    fail
	null
} 

auxiliary unify(TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, HashType t1, HashType t2) {
    EcoreUtil::copy(t1)
}


auxiliary unify(TypeSubstitutions substitutions, TypeVariable typeVar, BasicType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(TypeSubstitutions substitutions, BasicType basicType, TypeVariable typeVar) {
    unify(substitutions, typeVar, basicType)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}

auxiliary simplifySafe(Expression exp) {
	var simplifiedExp = simplify(exp)
    if (simplifiedExp.failed) exp else simplifiedExp.first
}


/*
 * expressions
 */

rule Script
	G |~ Script script
from {
	for (p : script.params) {
		G ||- p : var Type paramType
		G.add(p, paramType)			// store the type in the environment
		p.paramType = paramType		// and in the AST
	}
	var substitutions = new TypeSubstitutions()
	G |- substitutions |> script.exp : var Type texp	// shouldn't be boolean?
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : script.params) {
		p.paramType = typesubstitution(substitutions, p.paramType)
		{p.paramType instanceof BasicType}
	}
	
}

rule Input
	G ||~ Input input
from {
	var substitutions = new TypeSubstitutions()

    var inputTx = if (input.txRef.tx.body instanceof UserDefinedTxBody) input.txRef.tx.body as UserDefinedTxBody else null
	var outputIdx = input.txRef.idx
	
	var Script outputScript = null
	
	if (inputTx!==null && outputIdx<=inputTx.outputs.size) {
		outputScript = inputTx.outputs.get(outputIdx).script 
		G |~ outputScript	// all the params will have a basic type
	}
	
	for (var i=0; i<input.exps.size; i++) {
		var exp = input.exps.get(i)
		
		G |- substitutions |> exp : var BasicType texp
		
		// TODO: modify when serialized transactions will be analized (?) 
		if (inputTx!==null && outputScript!==null && 
		    outputScript.params.size==input.exps.size
		) {
			var param = outputScript.params.get(i)
			
			if(param.paramType.class != texp.class) {
				fail
					error "Invalid type '"+stringRep(texp)+"'. The parameter has type '"+stringRep(param.paramType)+"'."
					source exp
			} 
		}		
	}
}

rule BitcoinValue
	G |= BitcoinValue v
from {
	G |- new TypeSubstitutions() |> v.exp : var IntType intType
}

rule Parameter
	G ||- Parameter p : Type type
from {
	{
		p.paramType !== null
		type = EcoreUtil.copy(p.paramType)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
}

axiom NumeralLiteral
	G |- TypeSubstitutions substitutions |> NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- TypeSubstitutions substitutions |> StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Signature
	G |- TypeSubstitutions substitutions |> Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType

rule VariableReference
	G |- TypeSubstitutions substitutions |> VariableReference varRef : Type type
from {
	type = typesubstitution(substitutions, EcoreUtil.copy(env(G, varRef.ref, Type)))
	varRef.ref.paramType = type	// set the param type, useful just for the ui
}


rule Minus
	G |- TypeSubstitutions substitutions |> Minus minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> Plus plus : Type type
from {
    G |- substitutions |> plus.left : var Type leftType
    G |- substitutions |> plus.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
    {
    	type = BitcoinTMFactory::eINSTANCE.createStringType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
	}
    or
    {
       	type = BitcoinTMFactory::eINSTANCE.createIntType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
    }
}

rule Comparison
	G |- TypeSubstitutions substitutions |> Comparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Equals
	G |- TypeSubstitutions substitutions |> Equals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// equals between elements of the same type
	unify(substitutions, leftType, rightType)
}

rule BooleanNegation
	G |- TypeSubstitutions substitutions |> BooleanNegation negation : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> negation.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, boolType)
}

rule Or
	G |- TypeSubstitutions substitutions |> OrExpression orExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> orExp.left : var Type leftType
	G |- substitutions |> orExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule And
	G |- TypeSubstitutions substitutions |> AndExpression andExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> andExp.left : var Type leftType
	G |- substitutions |> andExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule ArithmeticSigned
	G |- TypeSubstitutions substitutions |> ArithmeticSigned signed : IntType intType
from {
	intType = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> signed.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, intType)
}

rule IfThenElse
	G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
	var boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> stmt.^if: var Type tIf
	G |- substitutions |> stmt.then: var Type tThen
	
	tIf = typesubstitution(substitutions, tIf)
	tThen = typesubstitution(substitutions, tThen)
	
	unify(substitutions, tIf, boolType)

	if (stmt.^else!==null) {
		G |- substitutions |> stmt.^else: var Type tElse
		tElse = typesubstitution(substitutions, tElse)
		unify(substitutions, tThen, tElse)
	}
	
	type=tThen
}

rule VerSig
	G |- TypeSubstitutions substitutions |> Versig versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, sigType)
	}	
}

rule Hash
	G |- TypeSubstitutions substitutions |> Hash hash: BitcoinTMFactory::eINSTANCE.createHashType
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Min
	G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> min.left: var Type tleft
	G |- substitutions |> min.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Max
	G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> max.left: var Type tleft
	G |- substitutions |> max.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Between
	G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> between.value: var Type tValue
	G |- substitutions |> between.left: var Type tLeft
	G |- substitutions |> between.right: var Type tRight
	
	tValue = typesubstitution(substitutions, tValue)
	tLeft = typesubstitution(substitutions, tLeft)
	tRight = typesubstitution(substitutions, tRight)
	
	unify(substitutions, tValue, t)
	unify(substitutions, tLeft, t)
	unify(substitutions, tRight, t)
}

rule Size
	G |- TypeSubstitutions substitutions |> Size size: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> size.value: var Type t
	
	t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
	G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
	var intType = BitcoinTMFactory::eINSTANCE.createIntType
	
	G |- substitutions |> after.time: var Type tvalue
	G |- substitutions |> after.continuation: texpr
	
	tvalue = typesubstitution(substitutions, tvalue)
	texpr = typesubstitution(substitutions, texpr)
	
	unify(substitutions, tvalue, intType)
}

/*
 * 
 * Expression Interpreter
 * 
 */
  
axiom InterpretNumberLiteral
    G |- NumberLiteral number ~> number.value

axiom InterpretStringLiteral
    G |- StringLiteral str ~> str.value

axiom InterpretBooleanLiteral
    G |- BooleanLiteral bool ~> bool.^true

rule InterpretMinus
    G |- Minus minus ~> Integer result
from {
    G |- minus.left ~> var Integer leftResult
    G |- minus.right ~> var Integer rightResult
    result = leftResult.intValue - rightResult.intValue
}

rule InterpretPlus
    G |- Plus plus ~> Object result
from {
    G |- plus.left ~> var Object leftResult
    G |- plus.right ~> var Object rightResult
    
    if (leftResult instanceof String || rightResult instanceof String) {
        var leftString = leftResult.toString
        var rightString = rightResult.toString
        result = leftString + rightString
    } else {
        // both are int if the expression is well-typed
        var leftInt = leftResult as Integer
        var rightInt = rightResult as Integer
        result = leftInt + rightInt
    }
}

rule InterpretArithmeticSigned
    G |- ArithmeticSigned signed ~> Integer result
from {
    G |- signed.exp ~> var Integer expResult
    result = -(expResult)
}

rule InterpretAnd
    G |- AndExpression and ~> Boolean result
from {
    G |- and.left ~> var Boolean leftResult
    G |- and.right ~> var Boolean rightResult
    result = leftResult.booleanValue && rightResult.booleanValue
}

rule InterpretOr
    G |- OrExpression orExp ~> Boolean result
from {
    G |- orExp.left ~> var Boolean leftResult
    G |- orExp.right ~> var Boolean rightResult
    result = leftResult.booleanValue || rightResult.booleanValue 
}

rule InterpretBooleanNegation
    G |- BooleanNegation neg ~> Boolean result
from {
    G |- neg.exp ~> var Boolean expResult
    result = !expResult
}

rule InterpretComparison
    G |- Comparison comparison ~> Boolean result
from {
    G |- comparison.left ~> var Comparable<Object> leftResult
    G |- comparison.right ~> var Object rightResult
    
    result = switch(comparison.op) {
    		case ">=": leftResult >= rightResult
    		case "<=": leftResult <= rightResult
    		case ">": leftResult > rightResult
    		case "<": leftResult < rightResult
    		default: null
    	}
    	
	if (result===null) {
		fail 
			error "Unexpecter operator "+comparison.op 
			source comparison
	}
}

rule InterpretEquals
    G |- Equals comparison ~> Boolean result
from {
	
	{
	    G |- comparison.left ~> var Object leftResult
	    G |- comparison.right ~> var Object rightResult
	    
	    result = switch(comparison.op) {
    		case "==": leftResult == rightResult
    		case "!=": leftResult != rightResult
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
	    
    } or {
    	comparison.left instanceof Signature
    	comparison.right instanceof Signature
    	// two signs are the same if the key and the modifier are the same
    	(comparison.left as Signature).key == (comparison.right as Signature).key;
    	(comparison.left as Signature).modifier == (comparison.right as Signature).modifier;
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    } or {
    	comparison.left instanceof VariableReference
    	comparison.right instanceof VariableReference
		// two refs are the same if they point to the same parameter
    	var leftResult = (comparison.left as VariableReference).ref 
    	var rightResult = (comparison.right as VariableReference).ref
    	leftResult == rightResult
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    }    
}

rule InterpretIfThenElse
    G |- IfThenElse stmt ~> Object result
from {
    G |- stmt.^if ~> var Boolean ifCondition
    
    if (ifCondition) {
        G |- stmt.then ~> var Object thenResult
        result = thenResult
    }
    else {
        G |- stmt.^else ~> var Object elseResult
        result = elseResult
    }
}

rule InterpretMin
    G |- Min stmt ~> Integer result
from {
    G |- stmt.left ~> var Integer leftRes
    G |- stmt.right ~> var Integer rightRes
    
    if (leftRes<=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretMax
    G |- Max stmt ~> Integer result
from {
    G |- stmt.left ~> var Integer leftRes
    G |- stmt.right ~> var Integer rightRes
    
    if (leftRes>=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretBetween
    G |- Between stmt ~> Boolean result
from {
    G |- stmt.value ~> var Integer valueRes
    G |- stmt.left ~> var Integer leftRes
    G |- stmt.right ~> var Integer rightRes
    result = leftRes<=valueRes && valueRes<rightRes
}

//rule InterpretHash
//    G |- Hash hash ~> String result
//from {
//
//    G |- hash.value ~> var Object expResult
//    
//    if (expResult instanceof Integer) {
//		var ByteBuffer b = ByteBuffer.allocate(4);		// integer are 32-bit
//		b.putInt(expResult)
//	    result = new String(Utils.sha256hash160(b.array))	
//    }
//	else if (expResult instanceof String) {
//	    result = new String(Utils.sha256hash160((expResult).bytes))
//	}
//}
//
//rule InterpretSize
//    G |- Size size ~> Integer result
//from {
//	//TODO
//}


/*
 * AST simplifier
 */
axiom SimplifyEObject
	G |= Expression obj ~> obj
	
rule SimplifyAnd
    G |= AndExpression and ~> Expression result
from {
	{
	    G |- and.left ~> var Boolean leftResult
	    {leftResult == true}	    
	    result = and.right
	} or {
	    G |- and.right ~> var Boolean rightResult
	    {rightResult == true}	    
	    result = and.left
	}
}

rule SimplifyOr
    G |= OrExpression and ~> Expression result
from {
	{
	    G |- and.left ~> var Boolean leftResult
	    {leftResult == false}	    
	    result = and.right
	} or {
	    G |- and.right ~> var Boolean rightResult
	    {rightResult == false}	    
	    result = and.left
	}
}

rule SimplifyPlus
    G |= Plus and ~> Expression result
from {
	{
	    G |- and.left ~> var Integer leftResult
	    {leftResult == 0}	    
	    result = and.right
	} or {
	    G |- and.right ~> var Integer rightResult
	    {rightResult == 0}	    
	    result = and.left
	}
}

rule SimplifyMinus
    G |= Minus and ~> Expression result
from {
	{
	    G |- and.left ~> var Integer leftResult
	    {leftResult == 0}	    
	    result = and.right
	} or {
	    G |- and.right ~> var Integer rightResult
	    {rightResult == 0}	    
	    result = and.left
	}
}

/*
 * 
 * rule invocations
 * 
 */
checkrule CheckScript for
    Script script
from {
	lambdaUtils.resetCounter
    empty |~ script
}

checkrule CheckInput for
    Input script
from {
	lambdaUtils.resetCounter
    empty ||~ script
}

checkrule CheckBitcoinValue for
    BitcoinValue v
from {
	lambdaUtils.resetCounter
    empty |= v
}
