import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.BasicType
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.HashLiteral
import it.unica.tcs.bitcoinTM.HashType
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Output
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.ParticipantDeclaration
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.ProcessDeclaration
import it.unica.tcs.bitcoinTM.ProtocolTransaction
import it.unica.tcs.bitcoinTM.SignOp
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.TransactionDeclaration
import it.unica.tcs.bitcoinTM.TransactionType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.TypeVariable
import it.unica.tcs.bitcoinTM.Typeable
import it.unica.tcs.bitcoinTM.UserTransactionDeclaration
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.bitcoinTM.VersigOp
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import java.math.BigInteger
import java.util.Arrays
import org.bitcoinj.core.Utils
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil

import static extension it.unica.tcs.utils.BitcoinJUtils.*
import it.unica.tcs.bitcoinTM.TransactionBody
import it.unica.tcs.bitcoinTM.SerialTransactionDeclaration

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

inject LambdaUtils lambdaUtils


auxiliary {
	notoccur(Type type, Type other)
        error stringRep(type) + " occurs in " + stringRep(other)
        
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    
    unify(TypeSubstitutions substitutions, Type left, Type right) : Type
        error "Cannot unify " + stringRep(left) + " with " + stringRep(right)
        
    simplifySafe(Expression exp) : Expression
}

judgments {

	typeS |- TypeSubstitutions substitutions |> Typeable exp : output Type
		error "Cannot type " + stringRep(exp)
		source exp
		
	type ||- Typeable p : output Type
		error "Cannot type " + stringRep(p)
		source p
	
//		
//	validate |= EObject obj
//		error "cannot type " + stringRep(obj)
//		source obj
	
	interpret |- Expression expression ~> output Object
	
	simplify |= Expression obj ~> output Expression
}

/*
 * auxiliary functions
 */

auxiliary notoccur(Type type, Type other) { true }

auxiliary notoccur(TypeVariable variable, TypeVariable other) {
    variable.value != other.value
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(TypeSubstitutions substitutions, Type t1, Type t2) {
    // if we get here we cannot unify the two types
    fail
	null
} 

auxiliary unify(TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, HashType t1, HashType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, TransactionType t1, TransactionType t2) {
    EcoreUtil::copy(t1)
}


auxiliary unify(TypeSubstitutions substitutions, TypeVariable typeVar, BasicType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(TypeSubstitutions substitutions, BasicType basicType, TypeVariable typeVar) {
    unify(substitutions, typeVar, basicType)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}

auxiliary simplifySafe(Expression exp) {
	var simplifiedExp = simplify(exp)
    if (simplifiedExp.failed) exp else simplifiedExp.first
}


/*
 * Type system rules
 */

axiom SerialTransactionDeclaration
	G ||- SerialTransactionDeclaration d : Type t

/**
 * Type check a user defined transactions:
 * - all the inputs are well typed
 * - all the inputs are well typed
 * - all the parameters are well typed and the type is basic (not generic)
 */
rule UserTransactionDeclaration
	G ||- UserTransactionDeclaration tx : Type t
from {
	
	for (p : tx.params) {
		G ||- p : var Type paramType
		G.add(p, paramType)			// store the type in the environment
		p.paramType = paramType		// and in the AST
	}
	
	var substitutions = new TypeSubstitutions()
	
	for (in : tx.body.inputs) {
		G |- substitutions |> in : var Type t1	// all inputs are well typed
	}
	
	for (out : tx.body.outputs) {
		G |- substitutions |> out : var Type t2	// all outputs are well typed
	}
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : tx.params) {
		p.paramType = typesubstitution(substitutions, p.paramType)
		{p.paramType instanceof BasicType}
	}
}

rule TransactionBody
	G |- TypeSubstitutions substitutions |> TransactionBody minus : Type t
from {
	
}


/**
 * An input is well typed if:
 * - the body of the redeemed transaction is well typed
 * - all the expressions are well typed and the type is basic (not generic)
 * - if the redeemed tx has free variables, check that the actual types corresponds to the formal ones 
 * - if the redeemed tx is user defined, all the expression type corresponds to the expected type of the parameter
 */
rule Input
	G |- TypeSubstitutions substitutions |> Input input : Type t
from {
	
	if (!input.isPlaceholder) {		
		// the body of the redeemed transaction is well typed
		var inputTx = input.txRef.tx
		G ||- inputTx : var Type t1
	
		// all the input expressions are well typed and the type is basic
		for (var i=0; i<input.exps.size; i++) {
			var exp = input.exps.get(i)
			G |- substitutions |> exp : var Type texp
			
			if (inputTx instanceof UserTransactionDeclaration)
				G.add(exp,texp)		// store the type for further checks (see below)
		}
	
		if (inputTx instanceof UserTransactionDeclaration) {
			
			// check the actual parameters type match the formal ones (Transaction)
			for (var i=0; i<input.txRef.actualParams.size; i++) {
				var actualParam = input.txRef.actualParams.get(i)
				var formalParam = inputTx.params.get(i)
				
				// all the actual parameters are well type and the type is basic
				G |- substitutions |> actualParam : var Type actualParamType
				
				// the actual param type must be unifiable with the formal param type
				unify(substitutions, actualParamType, formalParam.paramType)
			}
			
			// check the actual parameters type match the formal ones (Script)
			var outputIndex = input.outpoint
			var outputScript = inputTx.body.outputs.get(outputIndex).script
			for (var i=0; i<input.exps.size; i++) {
				var inputExp = input.exps.get(i)
				var outputParam = outputScript.params.get(i)
				
				var inputExpType = G.get(inputExp) as Type		// retrieve the type from G
				var outputParamType = outputParam.paramType 
				
				G.decrement(inputExp)					// remove the type from G
				
				// the actual param type must be unifiable with the formal param type
				unify(substitutions, inputExpType, outputParamType)
			}
		}
	}
}

/**
 * An Output is well typed if:
 * - all the scripts parameters are well typed and the type is basic (not generic)
 * - all the scripts expressions are well typed
 */
rule Output
	G |- TypeSubstitutions substitutions |> Output _output : Type t
from {
	var satoshis = _output.value.exp
	G |- new TypeSubstitutions() |> satoshis : var IntType intType
	
	var script = _output.script
	for (p : script.params) {
		G ||- p : var Type paramType
		G.add(p, paramType)			// store the type in the environment
		p.paramType = paramType		// and in the AST
	}

	G |- substitutions |> script.exp : var Type texp	// shouldn't be boolean?
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : script.params) {
		p.paramType = typesubstitution(substitutions, p.paramType)
		{p.paramType instanceof BasicType}
	}
}


rule Parameter
	G ||- Parameter p : Type type
from {
	{
		p.paramType !== null
		type = EcoreUtil.copy(p.paramType)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
}



/*
 * Expressions type system
 */
axiom NumeralLiteral
	G |- TypeSubstitutions substitutions |> NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- TypeSubstitutions substitutions |> StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom HashLiteral
	G |- TypeSubstitutions substitutions |> HashLiteral h : BitcoinTMFactory::eINSTANCE.createHashType

axiom Signature
	G |- TypeSubstitutions substitutions |> Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType


rule VariableReference
	G |- TypeSubstitutions substitutions |> VariableReference varRef : Type type
from {
	type = typesubstitution(substitutions, EcoreUtil.copy(env(G, varRef.ref, Type)))
	varRef.ref.paramType = type	// set the param type, useful just for the ui
}

rule Minus
	G |- TypeSubstitutions substitutions |> Minus minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> Plus plus : Type type
from {
    G |- substitutions |> plus.left : var Type leftType
    G |- substitutions |> plus.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
    {
    	type = BitcoinTMFactory::eINSTANCE.createStringType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
	}
    or
    {
       	type = BitcoinTMFactory::eINSTANCE.createIntType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
    }
}

rule Comparison
	G |- TypeSubstitutions substitutions |> Comparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Equals
	G |- TypeSubstitutions substitutions |> Equals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// equals between elements of the same type
	unify(substitutions, leftType, rightType)
}

rule BooleanNegation
	G |- TypeSubstitutions substitutions |> BooleanNegation negation : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> negation.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, boolType)
}

rule Or
	G |- TypeSubstitutions substitutions |> OrExpression orExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> orExp.left : var Type leftType
	G |- substitutions |> orExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule And
	G |- TypeSubstitutions substitutions |> AndExpression andExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> andExp.left : var Type leftType
	G |- substitutions |> andExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule ArithmeticSigned
	G |- TypeSubstitutions substitutions |> ArithmeticSigned signed : IntType intType
from {
	intType = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> signed.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, intType)
}

rule IfThenElse
	G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
	var boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> stmt.^if: var Type tIf
	G |- substitutions |> stmt.then: var Type tThen
	
	tIf = typesubstitution(substitutions, tIf)
	tThen = typesubstitution(substitutions, tThen)
	
	unify(substitutions, tIf, boolType)

	G |- substitutions |> stmt.^else: var Type tElse
	tElse = typesubstitution(substitutions, tElse)
	unify(substitutions, tThen, tElse)
	
	type=tThen
}

rule VerSig
	G |- TypeSubstitutions substitutions |> Versig versig : SignatureType sigType
from {
	sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, sigType)
	}
}

rule Hash
	G |- TypeSubstitutions substitutions |> Hash hash: BitcoinTMFactory::eINSTANCE.createHashType
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Min
	G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> min.left: var Type tleft
	G |- substitutions |> min.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Max
	G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> max.left: var Type tleft
	G |- substitutions |> max.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Between
	G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> between.value: var Type tValue
	G |- substitutions |> between.left: var Type tLeft
	G |- substitutions |> between.right: var Type tRight
	
	tValue = typesubstitution(substitutions, tValue)
	tLeft = typesubstitution(substitutions, tLeft)
	tRight = typesubstitution(substitutions, tRight)
	
	unify(substitutions, tValue, t)
	unify(substitutions, tLeft, t)
	unify(substitutions, tRight, t)
}

rule Size
	G |- TypeSubstitutions substitutions |> Size size: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> size.value: var Type t
	
	t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
	G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
	G |- substitutions |> after.continuation: texpr
	texpr = typesubstitution(substitutions, texpr)
}

/*
 * Protocols/Processes
 */
rule ParticipantDeclaration
	G ||- ParticipantDeclaration p : Type t
from {
	G ||- p.process : var Type t1
	for (d : p.defs) {
		 G ||- d : var Type t2
	}
}

rule ProcessDeclaration
	G ||- ProcessDeclaration p : Type t
from {
	for (param : p.params) {
		G ||- param : var Type paramType
		G.add(param, paramType)			// store the type in the environment 
		param.paramType = paramType		// and in the AST
	}
	
	var substitutions = new TypeSubstitutions()
	
}




rule SignOp
    G |- TypeSubstitutions substitutions |> SignOp plus : Type type
from {

}

rule ProtocolTransaction
    G |- TypeSubstitutions substitutions |> ProtocolTransaction tx : Type type
from {

}

rule VersigOp	// same as before, but check for transaction to be well-typed
	G |- TypeSubstitutions substitutions |> VersigOp versig : SignatureType sigType
from {
	sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, sigType)
	}
	
}

/*
 * 
 * Expression Interpreter
 * 
 */
  
axiom InterpretNumberLiteral
    G |- NumberLiteral number ~> number.value

axiom InterpretStringLiteral
    G |- StringLiteral str ~> str.value

axiom InterpretBooleanLiteral
    G |- BooleanLiteral bool ~> bool.^true

axiom InterpretHashLiteral
    G |- HashLiteral hash ~> hash.value

rule InterpretMinus
    G |- Minus minus ~> Integer result
from {
    G |- minus.left ~> var Integer leftResult
    G |- minus.right ~> var Integer rightResult
    result = leftResult.intValue - rightResult.intValue
}

rule InterpretPlus
    G |- Plus plus ~> Object result
from {
    G |- plus.left ~> var Object leftResult
    G |- plus.right ~> var Object rightResult
    
    if (leftResult instanceof String || rightResult instanceof String) {
        var leftString = leftResult.toString
        var rightString = rightResult.toString
        result = leftString + rightString
    } else {
        // both are int if the expression is well-typed
        var leftInt = leftResult as Integer
        var rightInt = rightResult as Integer
        result = leftInt + rightInt
    }
}

rule InterpretArithmeticSigned
    G |- ArithmeticSigned signed ~> Integer result
from {
    G |- signed.exp ~> var Integer expResult
    result = -(expResult)
}

rule InterpretAnd
    G |- AndExpression and ~> Boolean result
from {
    G |- and.left ~> var Boolean leftResult
    
    if (leftResult == false) {
    	result = false
    }
    else {
	    G |- and.right ~> var Boolean rightResult
	    result = leftResult.booleanValue && rightResult.booleanValue    	
    }    
}

rule InterpretOr
    G |- OrExpression orExp ~> Boolean result
from {
    G |- orExp.left ~> var Boolean leftResult
    
    if (leftResult == true) {
    	result = true
    }
    else {
	    G |- orExp.right ~> var Boolean rightResult
	    result = leftResult.booleanValue || rightResult.booleanValue 
    }    
}

rule InterpretBooleanNegation
    G |- BooleanNegation neg ~> Boolean result
from {
    G |- neg.exp ~> var Boolean expResult
    result = !expResult
}

rule InterpretComparison
    G |- Comparison comparison ~> Boolean result
from {
    G |- comparison.left ~> var Comparable<Object> leftResult
    G |- comparison.right ~> var Object rightResult
    
    result = switch(comparison.op) {
    		case ">=": leftResult >= rightResult
    		case "<=": leftResult <= rightResult
    		case ">": leftResult > rightResult
    		case "<": leftResult < rightResult
    		default: null
    	}
    	
	if (result===null) {
		fail 
			error "Unexpecter operator "+comparison.op 
			source comparison
	}
}

rule InterpretEquals
    G |- Equals comparison ~> Boolean result
from {
	
	{
	    G |- comparison.left ~> var Object leftResult
	    G |- comparison.right ~> var Object rightResult
	    
	    leftResult.class == rightResult.class
	    
	    var areEqual = leftResult==rightResult || Arrays.equals(leftResult as byte[], rightResult as byte[])
	    
	    result = switch(comparison.op) {
    		case "==": areEqual
    		case "!=": !areEqual
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
	    
    } or {
    	comparison.left instanceof Signature
    	comparison.right instanceof Signature
    	// two signs are the same if the key and the modifier are the same
    	(comparison.left as Signature).key == (comparison.right as Signature).key;
    	(comparison.left as Signature).modifier == (comparison.right as Signature).modifier;
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    } or {
    	comparison.left instanceof VariableReference
    	comparison.right instanceof VariableReference
		// two refs are the same if they point to the same parameter
    	var leftResult = (comparison.left as VariableReference).ref 
    	var rightResult = (comparison.right as VariableReference).ref
    	leftResult == rightResult
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    }    
}

rule InterpretIfThenElse
    G |- IfThenElse stmt ~> Object result
from {
    G |- stmt.^if ~> var Boolean ifCondition
    
    if (ifCondition) {
        G |- stmt.then ~> var Object thenResult
        result = thenResult
    }
    else {
        G |- stmt.^else ~> var Object elseResult
        result = elseResult
    }
}

rule InterpretMin
    G |- Min stmt ~> Integer result
from {
    G |- stmt.left ~> var Integer leftRes
    G |- stmt.right ~> var Integer rightRes
    
    if (leftRes<=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretMax
    G |- Max stmt ~> Integer result
from {
    G |- stmt.left ~> var Integer leftRes
    G |- stmt.right ~> var Integer rightRes
    
    if (leftRes>=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretBetween
    G |- Between stmt ~> Boolean result
from {
    G |- stmt.value ~> var Integer valueRes
    G |- stmt.left ~> var Integer leftRes
    G |- stmt.right ~> var Integer rightRes
    result = leftRes<=valueRes && valueRes<rightRes
}

rule InterpretHash
    G |- Hash hash ~> byte[] result
from {

    G |- hash.value ~> var Object expResult
    
    var bytes = expResult.toBytes
    
    result = 
	    switch(hash.type) {
	    	case "ripemd160": 	ripemd160(bytes) 
	    	case "sha256": 		sha256(bytes) 
	    	case "hash160": 	hash160(bytes)
	    	case "hash256": 	hash256(bytes)
	    	
	    } 
}

rule InterpretSize
    G |- Size size ~> Integer result
from {
	G |- size.value ~> var Integer res
	
	if (res==0) 
		result=0
	else {
		// ⌈(log2 |n| / 7)⌉
		result = Utils.encodeMPI(BigInteger.valueOf(res), false).length
	}
}


/*
 * AST simplifier
 */
axiom SimplifyEObject
	G |= Expression obj ~> obj
	
//rule SimplifyAnd
//    G |= AndExpression exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Boolean leftResult
//	    {leftResult == true}	    
//	    G |= exp.right ~> result
//	} or {
//	    G |- exp.right ~> var Boolean rightResult
//	    {rightResult == true}	    
//	    G |= exp.left ~> result
//	} or {
//		var newExp = BitcoinTMFactory::eINSTANCE.createAndExpression
//		newExp.left = simplifySafe(exp.left)
//		newExp.right = simplifySafe(exp.right)
//	}
//}
//
//rule SimplifyOr
//    G |= OrExpression exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Boolean leftResult
//	    {leftResult == false}	    
//	    G |= exp.right ~> result
//	} or {
//	    G |- exp.right ~> var Boolean rightResult
//	    {rightResult == false}	    
//	    G |= exp.left ~> result
//	} or {
//		exp.left = simplifySafe(exp.left)
//		exp.right = simplifySafe(exp.right)
//	}
//}
//
//rule SimplifyPlus
//    G |= Plus exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Integer leftResult
//	    {leftResult == 0}
//	    G |= exp.right ~> result    
//	} or {
//	    G |- exp.right ~> var Integer rightResult
//	    {rightResult == 0}	    
//	    G |= exp.left ~> result
//	} or {
//		exp.left = simplifySafe(exp.left)
//		exp.right = simplifySafe(exp.right)
//	}
//}
//
//rule SimplifyMinus
//    G |= Minus exp ~> Expression result
//from {
//	{
//	    G |- exp.left ~> var Integer leftResult
//	    {leftResult == 0}	    
//	    G |= exp.right ~> result
//	} or {
//	    G |- exp.right ~> var Integer rightResult
//	    {rightResult == 0}	    
//	    G |= exp.left ~> result
//	} or {
//		exp.left = simplifySafe(exp.left)
//		exp.right = simplifySafe(exp.right)
//	}
//}

/*
 * 
 * rule invocations
 * 
 */
checkrule CheckTransactionDeclaration for
    TransactionDeclaration stmt
from {
	lambdaUtils.resetCounter
    empty ||- stmt: var Type t
}
