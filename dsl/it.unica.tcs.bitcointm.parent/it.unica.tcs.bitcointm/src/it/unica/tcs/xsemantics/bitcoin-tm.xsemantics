/*
 * Copyright 2017 Nicola Atzei
 */

import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndScriptExpression
import it.unica.tcs.bitcoinTM.Ask
import it.unica.tcs.bitcoinTM.BasicType
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Check
import it.unica.tcs.bitcoinTM.Choice
import it.unica.tcs.bitcoinTM.Declaration
import it.unica.tcs.bitcoinTM.DeclarationLeft
import it.unica.tcs.bitcoinTM.DeclarationReference
import it.unica.tcs.bitcoinTM.DeclarationRight
import it.unica.tcs.bitcoinTM.ExpressionI
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.Hash160
import it.unica.tcs.bitcoinTM.Hash160Literal
import it.unica.tcs.bitcoinTM.Hash160Type
import it.unica.tcs.bitcoinTM.Hash256
import it.unica.tcs.bitcoinTM.Hash256Literal
import it.unica.tcs.bitcoinTM.Hash256Type
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.Input
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.KeyLiteral
import it.unica.tcs.bitcoinTM.KeyType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Model
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrScriptExpression
import it.unica.tcs.bitcoinTM.Output
import it.unica.tcs.bitcoinTM.Parallel
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Participant
import it.unica.tcs.bitcoinTM.ProcessDeclaration
import it.unica.tcs.bitcoinTM.ProcessReference
import it.unica.tcs.bitcoinTM.ProtocolIfThenElse
import it.unica.tcs.bitcoinTM.ProtocolTransactionReference
import it.unica.tcs.bitcoinTM.Put
import it.unica.tcs.bitcoinTM.Receive
import it.unica.tcs.bitcoinTM.Referrable
import it.unica.tcs.bitcoinTM.Ripemd160
import it.unica.tcs.bitcoinTM.Ripemd160Literal
import it.unica.tcs.bitcoinTM.Ripemd160Type
import it.unica.tcs.bitcoinTM.ScriptArithmeticSigned
import it.unica.tcs.bitcoinTM.ScriptBooleanNegation
import it.unica.tcs.bitcoinTM.ScriptComparison
import it.unica.tcs.bitcoinTM.ScriptEquals
import it.unica.tcs.bitcoinTM.ScriptMinus
import it.unica.tcs.bitcoinTM.ScriptPlus
import it.unica.tcs.bitcoinTM.Send
import it.unica.tcs.bitcoinTM.Sha256
import it.unica.tcs.bitcoinTM.Sha256Literal
import it.unica.tcs.bitcoinTM.Sha256Type
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Tau
import it.unica.tcs.bitcoinTM.TransactionBody
import it.unica.tcs.bitcoinTM.TransactionDeclaration
import it.unica.tcs.bitcoinTM.TransactionLiteral
import it.unica.tcs.bitcoinTM.TransactionType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.TypeVariable
import it.unica.tcs.bitcoinTM.Typeable
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.compiler.TransactionCompiler
import it.unica.tcs.lib.utils.BitcoinUtils
import it.unica.tcs.utils.ASTUtils
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import java.math.BigInteger
import java.util.Map
import org.bitcoinj.core.DumpedPrivateKey
import org.bitcoinj.core.Transaction
import org.bitcoinj.core.Utils
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

inject LambdaUtils lambdaUtils
inject extension ASTUtils astUtils
inject extension TransactionCompiler compiler

auxiliary {
        
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    
    unify(TypeSubstitutions substitutions, Type left, Type right) : Type
        error "Cannot unify " + stringRep(left) + " with " + stringRep(right)
    
    failIfNotBasic(Type type, EObject obj)    
}

judgments {

	typeExpression |- TypeSubstitutions substitutions |> Typeable exp : output Type
		error "Cannot type " + stringRep(exp)
		source exp
		
	interpret |- ExpressionI expression |> Map<Referrable,Object> rho ~> output Object
}

/*
 * auxiliary functions
 */
 
auxiliary failIfNotBasic(Type type, EObject obj) {
	if (!(type instanceof BasicType)) {
		fail
		error "basic type expected"
		source obj
	} else {
		// type is basic, set within the AST
		if (obj instanceof DeclarationLeft) {
			obj.type = type
		}
	}
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(TypeSubstitutions substitutions, Type t1, Type t2) {
    // if we get here we cannot unify the two types
    fail
	error "Cannot unify type "+t1+" with type "+t2
	null
} 

auxiliary unify(TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash160Type t1, Hash160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash256Type t1, Hash256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Ripemd160Type t1, Ripemd160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Sha256Type t1, Sha256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash256Type t1, Sha256Type t2) {
    unify(substitutions,t2,t1)
}

auxiliary unify(TypeSubstitutions substitutions, Sha256Type t1, Hash256Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, Hash160Type t1, Ripemd160Type t2) {
    unify(substitutions,t2,t1)
}

auxiliary unify(TypeSubstitutions substitutions, Ripemd160Type t1, Hash160Type t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, KeyType t1, KeyType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, TransactionType t1, TransactionType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable typeVar, BasicType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(TypeSubstitutions substitutions, BasicType basicType, TypeVariable typeVar) {
    unify(substitutions, typeVar, basicType)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}



/*
 * Type system rules
 */

rule Parameter
	G |- TypeSubstitutions substitutions |> Parameter p : Type type
from {
	{
		p.type !== null
		type = EcoreUtil.copy(p.type)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
	G.add(p, type)
}

rule Declaration
	G |- TypeSubstitutions substitutions |> Declaration decl : Type type
from {
	G |- substitutions |> decl.left : var Type leftType
	G |- substitutions |> decl.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// right part is unifiable with left one, the result is the type of the declaration
	type = unify(substitutions, leftType, rightType)
	
	failIfNotBasic(type, decl.left)
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : decl.left.params) {
		var ptype = env(G, p, Type)
		ptype = typesubstitution(substitutions, ptype)
		failIfNotBasic(ptype, p)
	}
	
	decl.left.type = type	// store the type in the AST
}

rule DeclarationLeft
	G |- TypeSubstitutions substitutions |> DeclarationLeft d : Type type
from {
	// type all the actual parameters
	for (param : d.params) {
		G |- substitutions |> param : var Type paramType
	}

	{
		d.type !== null
		type = EcoreUtil.copy(d.type)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
	G.add(d, type)
}

rule DeclarationRight
	G |- TypeSubstitutions substitutions |> DeclarationRight p : Type type
from {
	G |- substitutions |> p.value : type
}

rule DeclarationReference
	G |- TypeSubstitutions substitutions |> DeclarationReference varRef : Type type
from {
	type = env(G, varRef.ref, Type)						// reference type
	type = typesubstitution(substitutions, type)		// apply substitutions
	
	val ref = varRef.ref
	if (ref instanceof DeclarationLeft) {
		// check the actual parameters type match the formal ones
		for (var i=0; i<varRef.actualParams.size; i++) {
			var actualParam = varRef.actualParams.get(i)
			var formalParam = ref.params.get(i)
			
			// get formal parameter type
			var formalParamType = env(G, formalParam, Type)
			// apply eventual substitutions to get the basic type
			formalParamType = typesubstitution(substitutions, formalParamType)
			// ensure it's basic
			failIfNotBasic(formalParamType, formalParam)
			
			// all the actual parameters are well typed
			G |- substitutions |> actualParam : var Type actualParamType
			// apply eventual substitutions
			actualParamType = typesubstitution(substitutions, actualParamType)
			
			// the actual param type must be unifiable with the formal param type
			unify(substitutions, actualParamType, formalParamType)
		}
	}
}


/**
 * Type check a user defined transactions:
 * - all the parameters are well typed and the type is basic (not generic)
 */
//rule TransactionDeclaration
//	G |- TypeSubstitutions substitutions |> TransactionDeclaration tx : TransactionType type
//from {
//	
//	type = BitcoinTMFactory::eINSTANCE.createTransactionType
//
//	// type like a normal declaration	
//	G |- substitutions |> tx as Declaration : var Type tmpType
//	tmpType = typesubstitution(substitutions, tmpType)
//	unify(substitutions, type, tmpType)
//}

/*
 * - all the inputs are well typed
 * - all the outputs are well typed
 */
rule TransactionBody
	G |- TypeSubstitutions substitutions |> TransactionBody body : BitcoinTMFactory::eINSTANCE.createTransactionType
from {
	
	for (in : body.inputs) {
		G |- substitutions |> in : var Type t1	// all inputs are well typed
	}
	
	for (out : body.outputs) {
		G |- substitutions |> out : var Type t2	// all outputs are well typed
	}
}


/**
 * An input is well typed if:
 * - the body of the redeemed transaction is well typed
 * - all the expressions are well typed and the type is basic (not generic)
 * - if the redeemed tx has free variables, check that the actual types corresponds to the formal ones 
 * - if the redeemed tx is user defined, all the expression type corresponds to the expected type of the parameter
 */
rule Input
	G |- TypeSubstitutions substitutions |> Input input : Type t
from {
	
	if (!input.isPlaceholder) {
		
		val txType = BitcoinTMFactory::eINSTANCE.createTransactionType
		
		// the body of the redeemed transaction is well typed
		G |- substitutions |> input.txRef : var Type t1		// eventual tx parameters have type BasicType
		t1 = typesubstitution(substitutions, t1)
		unify(substitutions, t1, txType)
		
		{
			// all the input expressions are well typed and the type is basic
			for (var i=0; i<input.exps.size; i++) {
				var exp = input.exps.get(i)
				G |- substitutions |> exp : var Type texp	// type can be inferred by the "invocation" of inputTx
				texp = typesubstitution(substitutions, texp)
				failIfNotBasic(texp, exp)
			}
		} or {
			/*
			 * input.txRef can be
			 * - a transaction reference (serial or not)
			 * - an expression which evaluate to a transaction literal
			 */
			val inputTxRef = input.txRef
			
			if (inputTxRef instanceof DeclarationReference) {
				
				var inputTx = inputTxRef.eContainer as TransactionDeclaration
		
				// check the actual parameters type match the formal ones (Transaction)
				for (var i=0; i<inputTxRef.actualParams.size; i++) {
					var actualParam = inputTxRef.actualParams.get(i)
					var formalParam = inputTx.left.params.get(i)
					
					// get formal parameter type
					var formalParamType = env(G, formalParam, Type)
					// apply eventual substitutions to get the basic type
					formalParamType = typesubstitution(substitutions, formalParamType)
					// ensure it's basic
					failIfNotBasic(formalParamType, formalParam)
					
					// all the actual parameters are well typed
					G |- substitutions |> actualParam : var Type actualParamType
					// apply eventual substitutions
					actualParamType = typesubstitution(substitutions, actualParamType)
					
					// the actual param type must be unifiable with the formal param type
					unify(substitutions, actualParamType, formalParamType)
				}
				
				// check the actual parameters type match the formal ones (Script)
				var outputIndex = input.outpoint
				var outputScript = (inputTx.right.value as TransactionBody).outputs.get(new Long(outputIndex).intValue).script
				for (var i=0; i<input.exps.size; i++) {
					var inputExp = input.exps.get(i)
					var outputParam = outputScript.params.get(i)
					
					// get formal parameter type
					var formalParamType = env(G, outputParam, Type)
					// apply eventual substitutions to get the basic type
					formalParamType = typesubstitution(substitutions, formalParamType)
					// ensure it's basic
					failIfNotBasic(formalParamType, outputParam)
					
					// all the actual parameters are well typed
					G |- substitutions |> inputExp : var Type actualParamType
					// apply eventual substitutions
					actualParamType = typesubstitution(substitutions, actualParamType)
					
					// the actual param type must be unifiable with the formal param type
					unify(substitutions, actualParamType, formalParamType)
				}
			}
		}
	}
}

/**
 * An Output is well typed if:
 * - all the scripts parameters are well typed and the type is basic (not generic)
 * - all the scripts expressions are well typed
 */
rule Output
	G |- TypeSubstitutions substitutions |> Output _output : Type t
from {
	var satoshis = _output.value.exp
	G |- new TypeSubstitutions() |> satoshis : var IntType intType
	
	var script = _output.script
	for (p : script.params) {
		G |- substitutions |> p : var Type type
	}

	val long value = interpret(satoshis, newHashMap).first as Long
	
	var expectedType = 
		if (value==0) {
			BitcoinTMFactory::eINSTANCE.createStringType
		}
		else {
			BitcoinTMFactory::eINSTANCE.createBooleanType
		}
	
	G |- substitutions |> script.exp : expectedType // shouldn't be boolean?
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (p : script.params) {
		var ptype = env(G, p, Type)
		ptype = typesubstitution(substitutions, ptype)
		failIfNotBasic(ptype, p)
		p.type = ptype
	}
}





/*
 * Expressions type system
 */
axiom NumeralLiteral
	G |- TypeSubstitutions substitutions |> NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- TypeSubstitutions substitutions |> StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Hash160Literal
	G |- TypeSubstitutions substitutions |> Hash160Literal h : BitcoinTMFactory::eINSTANCE.createHash160Type

axiom Hash256Literal
	G |- TypeSubstitutions substitutions |> Hash256Literal h : BitcoinTMFactory::eINSTANCE.createHash256Type

axiom Ripemd160Literal
	G |- TypeSubstitutions substitutions |> Ripemd160Literal h : BitcoinTMFactory::eINSTANCE.createRipemd160Type

axiom Sha256Literal
	G |- TypeSubstitutions substitutions |> Sha256Literal h : BitcoinTMFactory::eINSTANCE.createSha256Type

axiom KeyLiteral
	G |- TypeSubstitutions substitutions |> KeyLiteral key : BitcoinTMFactory::eINSTANCE.createKeyType
	
axiom TransactionLiteral
	G |- TypeSubstitutions substitutions |> TransactionLiteral tx : BitcoinTMFactory::eINSTANCE.createTransactionType

rule Minus
	G |- TypeSubstitutions substitutions |> ScriptMinus minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> ScriptPlus plus : Type type
from {
    G |- substitutions |> plus.left : var Type leftType
    G |- substitutions |> plus.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
    {
       	type = BitcoinTMFactory::eINSTANCE.createIntType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
	}
    or
    {
    	type = BitcoinTMFactory::eINSTANCE.createStringType
		// the terms type must be unifiable with string type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
    }
}

rule Comparison
	G |- TypeSubstitutions substitutions |> ScriptComparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Equals
	G |- TypeSubstitutions substitutions |> ScriptEquals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// equals between elements of the same type
	unify(substitutions, leftType, rightType)
}

rule BooleanNegation
	G |- TypeSubstitutions substitutions |> ScriptBooleanNegation negation : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> negation.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, boolType)
}

rule Or
	G |- TypeSubstitutions substitutions |> OrScriptExpression orExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> orExp.left : var Type leftType
	G |- substitutions |> orExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule And
	G |- TypeSubstitutions substitutions |> AndScriptExpression andExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> andExp.left : var Type leftType
	G |- substitutions |> andExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule ArithmeticSigned
	G |- TypeSubstitutions substitutions |> ScriptArithmeticSigned signed : IntType intType
from {
	intType = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> signed.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, intType)
}

rule IfThenElse
	G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
	var boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> stmt.^if: var Type tIf
	G |- substitutions |> stmt.then: var Type tThen
	
	tIf = typesubstitution(substitutions, tIf)
	tThen = typesubstitution(substitutions, tThen)
	
	unify(substitutions, tIf, boolType)

	G |- substitutions |> stmt.^else: var Type tElse
	tElse = typesubstitution(substitutions, tElse)
	unify(substitutions, tThen, tElse)
	
	type=tThen
}

rule VerSig
	G |- TypeSubstitutions substitutions |> Versig versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var keyType = BitcoinTMFactory::eINSTANCE.createKeyType
	
	for (k : versig.pubkeys) {
		G |- substitutions |> k : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, keyType)
	}

	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type ts
		ts = typesubstitution(substitutions, ts)
		unify(substitutions, ts, sigType)
	}
}

rule Signature
	G |- TypeSubstitutions substitutions |> Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType
from {
	var keyType = BitcoinTMFactory::eINSTANCE.createKeyType

	G |- substitutions |> s.key : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, keyType)
}

rule Hash160
	G |- TypeSubstitutions substitutions |> Hash160 hash: BitcoinTMFactory::eINSTANCE.createHash160Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Hash256
	G |- TypeSubstitutions substitutions |> Hash256 hash: BitcoinTMFactory::eINSTANCE.createHash256Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Ripemd160
	G |- TypeSubstitutions substitutions |> Ripemd160 hash: BitcoinTMFactory::eINSTANCE.createRipemd160Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Sha256
	G |- TypeSubstitutions substitutions |> Sha256 hash: BitcoinTMFactory::eINSTANCE.createSha256Type
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
	
	if (!(t instanceof BasicType)) {
		fail
			error "basic type expected"
			source hash.value			
	}
}

rule Min
	G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> min.left: var Type tleft
	G |- substitutions |> min.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Max
	G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> max.left: var Type tleft
	G |- substitutions |> max.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Between
	G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> between.value: var Type tValue
	G |- substitutions |> between.left: var Type tLeft
	G |- substitutions |> between.right: var Type tRight
	
	tValue = typesubstitution(substitutions, tValue)
	tLeft = typesubstitution(substitutions, tLeft)
	tRight = typesubstitution(substitutions, tRight)
	
	unify(substitutions, tValue, t)
	unify(substitutions, tLeft, t)
	unify(substitutions, tRight, t)
}

rule Size
	G |- TypeSubstitutions substitutions |> Size size: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> size.value: var Type t
	
	t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
	G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
	G |- substitutions |> after.continuation: texpr
	texpr = typesubstitution(substitutions, texpr)
}

/*
 * Protocols/Processes
 */
rule Participant
	G |- TypeSubstitutions substitutions |> Participant p : Type t
from {
	for (v : p.variables) {
		G |- substitutions |> v : t	
	}
	
	for (d : p.defs) {
		G |- substitutions |> d : t	
	}
	
	G |- substitutions |> p.process : t
}

rule ProcessDeclaration
	G |- TypeSubstitutions substitutions |> ProcessDeclaration p : Type t
from {
	for (param : p.params) {
		G |- substitutions |> param : var Type type
		G.add(param, type)			// store the type in the environment 
	}

	// process is well typed
	G |- substitutions |> p.process : t
	
	// all the parameters should have a basic type (generic types are not allowed)
	for (param : p.params) {
		// get formal parameter type
		var formalParamType = env(G, param, Type)
		// apply eventual substitutions to get the basic type
		formalParamType = typesubstitution(substitutions, formalParamType)
		// ensure it's basic
		failIfNotBasic(formalParamType, param)
	}
}
 
rule Choice
	G |- TypeSubstitutions substitutions |> Choice choice : Type type
from {
	for (a : choice.actions) {
		G |- substitutions |> a : var Type t
		if (a.next!==null) {
			G |- substitutions |> a.next : var Type t1
		}
	}
}

rule Parallel
	G |- TypeSubstitutions substitutions |> Parallel p : Type type
from {
	G |- substitutions |> p.left : var Type t
	G |- substitutions |> p.right : var Type t1
}

rule ProcessReference
	G |- TypeSubstitutions substitutions |> ProcessReference pRef : Type type
from {
	// check the actual parameters type match the formal ones (Transaction)
	for (var i=0; i<pRef.actualParams.size; i++) {
		var actualParam = pRef.actualParams.get(i)
		var formalParam = pRef.ref.params.get(i)

		// get formal parameter type
		var formalParamType = env(G, formalParam, Type)
		// apply eventual substitutions to get the basic type
		formalParamType = typesubstitution(substitutions, formalParamType)
		// ensure it's basic
		failIfNotBasic(formalParamType, formalParam)

		// all the actual parameters are well type and the type is basic
		G |- substitutions |> actualParam : var Type actualParamType
		
		// the actual param type must be unifiable with the formal param type
		unify(substitutions, actualParamType, formalParamType)
	}
}

rule ProtocolIfThenElse
	G |- TypeSubstitutions substitutions |> ProtocolIfThenElse ifThenElse : Type type
from {
	G |- substitutions |> ifThenElse.exp : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createBooleanType)
	
	G |- substitutions |> ifThenElse.^then : var Type t1
	if (ifThenElse.^else!==null) {
		G |- substitutions |> ifThenElse.^else : var Type t2
	}
}

rule Tau
	G |- TypeSubstitutions substitutions |> Tau tau : Type type
from {}

rule Ask
	G |- TypeSubstitutions substitutions |> Ask ask : Type type
from {
	for (txRef : ask.txRefs) {
		G |- substitutions |> txRef : var Type t
		t = typesubstitution(substitutions, t)
	}
}

rule Put
	G |- TypeSubstitutions substitutions |> Put put : Type type
from {
	for (txRef : put.txRefs) {
		G |- substitutions |> txRef : var Type t
	}
}

rule Check
	G |- TypeSubstitutions substitutions |> Check a : Type type
from {
	G |- substitutions |> a.exp : var Type t
	t = typesubstitution(substitutions, t)
	unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createBooleanType)
}

rule Send
	G |- TypeSubstitutions substitutions |> Send send : Type type
from {
	G |- substitutions |> send.message : var BasicType t
}

rule Receive
	G |- TypeSubstitutions substitutions |> Receive receive : Type type
from {
	G |- substitutions |> receive.^var : var BasicType t
}


/*
 * ProtocolExpressions
 */
//rule SignOp
//    G |- TypeSubstitutions substitutions |> SignOp sig : BitcoinTMFactory::eINSTANCE.createSignatureType
//from {
//	G |- substitutions |> sig.tx : var Type t
//	t = typesubstitution(substitutions, t)
//	unify(substitutions, t, BitcoinTMFactory::eINSTANCE.createTransactionType)
//}
//
//rule VersigOp	// same as before, but check for transaction to be well-typed
//	G |- TypeSubstitutions substitutions |> VersigOp versig : BitcoinTMFactory::eINSTANCE.createBooleanType
//from {
//	G |- substitutions |> versig.tx : var TransactionType t
//	
//	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
//	
//	for (s : versig.signatures) {
//		G |- substitutions |> s : var Type t1
//		t1 = typesubstitution(substitutions, t1)
//		unify(substitutions, t1, sigType)
//	}
//}

rule ProtocolTransactionReference
    G |- TypeSubstitutions substitutions |> ProtocolTransactionReference txRef : Type t
from {
	if (txRef.substitution!==null) {
		G |- substitutions |> txRef.substitution: var Type t1
	}
}


/*
 * 
 * Expression Interpreter
 * 
 */

rule InterpretDeclarationReference
	G |- DeclarationReference v |> Map<Referrable, Object> rho ~> Object res
from {
	{
		val decl = v.ref.eContainer as Declaration
		
		for (var i=0; i<v.actualParams.size; i++) {
			val actual = v.actualParams.get(i)
			val formal = (v.ref as DeclarationLeft).params.get(i)
			
			G |- actual |> rho ~> var Object value
			rho.put(formal, value)	
		}
		
		G |- decl.right.value |> rho ~> res	
	}
	or {	// e.g. Script or Tx params
		{rho.containsKey(v.ref)}
		res = rho.get(v.ref)				
	}
}
  
axiom InterpretNumberLiteral
    G |- NumberLiteral number |> Map<Referrable, Object> rho ~> number.value

axiom InterpretStringLiteral
    G |- StringLiteral str |> Map<Referrable, Object> rho ~> str.value

axiom InterpretBooleanLiteral
    G |- BooleanLiteral bool |> Map<Referrable, Object> rho ~> bool.^true

axiom InterpretHash160Literal
    G |- Hash160Literal hash |> Map<Referrable, Object> rho ~> new it.unica.tcs.lib.Hash.Hash160(hash.value)

axiom InterpretHash256Literal
    G |- Hash256Literal hash |> Map<Referrable, Object> rho ~> new it.unica.tcs.lib.Hash.Hash256(hash.value)

axiom InterpretRipemd160Literal
    G |- Ripemd160Literal hash |> Map<Referrable, Object> rho ~> new it.unica.tcs.lib.Hash.Ripemd160(hash.value)

axiom InterpretSha256Literal
    G |- Sha256Literal hash |> Map<Referrable, Object> rho ~> new it.unica.tcs.lib.Hash.Sha256(hash.value)

axiom InterpretKeyLiteral
    G |- KeyLiteral key |> Map<Referrable, Object> rho ~> DumpedPrivateKey.fromBase58(null, key.value)

axiom InterpretTransactionLiteral
    G |- TransactionLiteral tx |> Map<Referrable, Object> rho ~> new Transaction(tx.networkParams, BitcoinUtils.decode(tx.value))



//rule InterpretTransactionBody
//    G |- TransactionBody txBody |> Map<Referrable, Object> rho ~> Transaction res
//from {
//	/*
//	 * the only way to invoke this rule is by a DeclarationReference.
//	 * It adds the actual value to rho, so this exp should be closed
//	 */
//	val TransactionDeclaration decl = txBody.txDeclaration
//	val txBuilder = decl.compileTransaction
//	
//	for (p : decl.left.params) {
//		txBuilder.bindVariable(p.name, rho.get(p))
//	}
//	
//	if (!txBuilder.isReady) {
//		println("ERROR: txbuilder seems to be not ready")
//		println(txBuilder)
//	}
//	
//	res = txBuilder.toTransaction
//}

rule InterpretMinus
    G |- ScriptMinus minus |> Map<Referrable, Object> rho ~> Long result
from {
    G |- minus.left |> rho ~> var Long leftResult
    G |- minus.right |> rho ~> var Long rightResult
    result = leftResult - rightResult
}

rule InterpretPlus
    G |- ScriptPlus plus |> Map<Referrable, Object> rho ~> Object result
from {
    G |- plus.left |> rho ~> var Object leftResult
    G |- plus.right |> rho ~> var Object rightResult
    
    if (leftResult instanceof String || rightResult instanceof String) {
        var leftString = leftResult.toString
        var rightString = rightResult.toString
        result = leftString + rightString
    } else {
        // both are int if the expression is well-typed
        var leftInt = leftResult as Long
        var rightInt = rightResult as Long
        result = leftInt + rightInt
    }
}

rule InterpretArithmeticSigned
    G |- ScriptArithmeticSigned signed |> Map<Referrable, Object> rho ~> Long result
from {
    G |- signed.exp |> rho ~> var Long expResult
    result = -(expResult)
}

rule InterpretAnd
    G |- AndScriptExpression and |> Map<Referrable, Object> rho ~> Boolean result
from {
	{
	    G |- and.left |> rho ~> var Boolean leftResult
	    
	    if (leftResult == false) {
	    	result = false
	    }
	    else {
		    G |- and.right |> rho ~> var Boolean rightResult
		    result = rightResult.booleanValue    	
	    }
	} or {
	    G |- and.right |> rho ~> var Boolean rightResult
	    
	    if (rightResult == false) {
	    	result = false
	    }
	    else {
		    G |- and.left |> rho ~> var Boolean leftResult
		    result = leftResult.booleanValue    	
	    }
		
	}   
}

rule InterpretOr
    G |- OrScriptExpression orExp |> Map<Referrable, Object> rho ~> Boolean result
from {
	{
	    G |- orExp.left |> rho ~> var Boolean leftResult
	    
	    if (leftResult == true) {
	    	result = true
	    }
	    else {
		    G |- orExp.right |> rho ~> var Boolean rightResult
		    result = rightResult.booleanValue 
	    }
    } or {
    	G |- orExp.right |> rho ~> var Boolean rightResult
	    
	    if (rightResult == true) {
	    	result = true
	    }
	    else {
		    G |- orExp.left |> rho ~> var Boolean leftResult
		    result = leftResult.booleanValue 
	    }
    }
}

rule InterpretBooleanNegation
    G |- ScriptBooleanNegation neg |> Map<Referrable, Object> rho ~> Boolean result
from {
    G |- neg.exp |> rho ~> var Boolean expResult
    result = !expResult
}

rule InterpretComparison
    G |- ScriptComparison comparison |> Map<Referrable, Object> rho ~> Boolean result
from {
    G |- comparison.left |> rho ~> var Comparable<Object> leftResult
    G |- comparison.right |> rho ~> var Object rightResult
    
    result = switch(comparison.op) {
    		case ">=": leftResult >= rightResult
    		case "<=": leftResult <= rightResult
    		case ">": leftResult > rightResult
    		case "<": leftResult < rightResult
    		default: null
    	}
    	
	if (result===null) {
		fail 
			error "Unexpecter operator "+comparison.op 
			source comparison
	}
}

rule InterpretEquals
    G |- ScriptEquals comparison |> Map<Referrable, Object> rho ~> Boolean result
from {
	
	{
	    G |- comparison.left |> rho ~> var Object leftResult
	    G |- comparison.right |> rho ~> var Object rightResult
	    	    	    
	    var areEqual = leftResult==rightResult
	    
	    result = switch(comparison.op) {
    		case "==": areEqual
    		case "!=": !areEqual
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpected operator "+comparison.op 
				source comparison
		}
	    
    } or {
    	// TODO: remove this case
    	comparison.left instanceof Signature
    	comparison.right instanceof Signature
    	// two signs are the same if the key and the modifier are the same
    	(comparison.left as Signature).key == (comparison.right as Signature).key;
    	(comparison.left as Signature).modifier == (comparison.right as Signature).modifier;
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    } or {
    	comparison.left instanceof DeclarationReference
    	comparison.right instanceof DeclarationReference
		// two refs are the same if they point to the same parameter
    	var leftResult = (comparison.left as DeclarationReference).ref 
    	var rightResult = (comparison.right as DeclarationReference).ref
    	leftResult == rightResult
    	
    	result = switch(comparison.op) {
    		case "==": true
    		case "!=": false
    		default: null
    	}
    	
		if (result===null) {
			fail 
				error "Unexpecter operator "+comparison.op 
				source comparison
		}
    }    
}

rule InterpretIfThenElse
    G |- IfThenElse stmt |> Map<Referrable, Object> rho ~> Object result
from {
    G |- stmt.^if |> rho ~> var Boolean ifCondition
    
    if (ifCondition) {
        G |- stmt.then |> rho ~> var Object thenResult
        result = thenResult
    }
    else {
        G |- stmt.^else |> rho ~> var Object elseResult
        result = elseResult
    }
}

rule InterpretMin
    G |- Min stmt |> Map<Referrable, Object> rho ~> Long result
from {
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes
    
    if (leftRes<=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretMax
    G |- Max stmt |> Map<Referrable, Object> rho ~> Long result
from {
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes
    
    if (leftRes>=rightRes)
        result = leftRes
    else 
        result = rightRes
}

rule InterpretBetween
    G |- Between stmt |> Map<Referrable, Object> rho ~> Boolean result
from {
    G |- stmt.value |> rho ~> var Long valueRes
    G |- stmt.left |> rho ~> var Long leftRes
    G |- stmt.right |> rho ~> var Long rightRes
    result = leftRes<=valueRes && valueRes<rightRes
}

rule InterpretHash
    G |- Hash hash |> Map<Referrable, Object> rho ~> it.unica.tcs.lib.Hash result
from {

    G |- hash.value |> rho ~> var Object expResult
    
    // hash the bytes
    if (hash instanceof Hash160)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Hash160)
    else if (hash instanceof Hash256)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Hash256)
    else if (hash instanceof Ripemd160)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Ripemd160)
    else if (hash instanceof Sha256)
	    result = BitcoinUtils.hash(expResult, it.unica.tcs.lib.Hash.Sha256)
	else {
		fail 
		error "Unexpecter instance "+hash.class 
		source hash
	}
}

rule InterpretSize
    G |- Size size |> Map<Referrable, Object> rho ~> Long result
from {
	G |- size.value |> rho ~> var Long res
	
	if (res==0) 
		result=0L
	else {
		// ⌈(log2 |n| / 7)⌉
		result = Long.valueOf(Utils.encodeMPI(BigInteger.valueOf(res), false).length)
	}
}


rule TypeCheckModel
	G |- TypeSubstitutions substitutions |> Model model : BitcoinTMFactory::eINSTANCE.createTransactionType
from {

	for (p: EcoreUtil2.getAllContentsOfType(model, Participant)) {
	    G |- substitutions |> p: var Type t
	}
	
	for (p: EcoreUtil2.getAllContentsOfType(model, Declaration)) {
	    G |- substitutions |> p: var Type t
	}
}
	

/*
 * 
 * rule invocations
 * 
 */
checkrule CheckModel for
    Model stmt
from {
	lambdaUtils.resetCounter
    empty |- new TypeSubstitutions |> stmt: var Type t
}
