import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import it.unica.tcs.bitcoinTM.BitcoinTMFactory

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

judgments {

	type |- Expression expression : output Type
		error "cannot type " + stringRep(expression)
		source expression
		
//	vartype ||- VariableDeclaration fn : output Type
//		error "cannot type " + stringRep(fn)
//		source fn
//		
//	validate |= EObject obj
//		error "cannot type " + stringRep(obj)
//		source obj
	
//	interpret |- Expression expression ~> output Object
}


/*
 * expressions
 */
axiom NumeralLiteral
	G |- NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

rule Minus
	G |- Minus minus : BitcoinTMFactory::eINSTANCE.createIntType
from {
	var IntType intType
	G |- minus.left : intType
	G |- minus.right : intType
}

rule Plus
    G |- Plus plus : Type type
from {
    G |- plus.left : var Type leftType
    G |- plus.right : var Type rightType
    
    {
        (leftType instanceof StringType && rightType instanceof StringType)
        type = BitcoinTMFactory::eINSTANCE.createStringType
    }
    or
    {
        (leftType instanceof IntType && rightType instanceof IntType)
        type = leftType // i.e., IntType
    }
}

rule Comparison
	G |- Comparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var IntType intType
	G |- comparison.left : intType
	G |- comparison.right : intType
}

rule Equals
	G |- Equals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- comparison.left : var Type leftType
	G |- comparison.right : var Type rightType
	
	// can compare only if they have the same type
	(leftType.eClass == rightType.eClass)
}

rule BooleanNegation
	G |- BooleanNegation negation : BooleanType boolType
from {
	G |- negation.exp : boolType
}

rule Or
	G |- OrExpression orExp : BooleanType boolType
from {
	G |- orExp.left : boolType
	G |- orExp.right : boolType
}

rule And
	G |- AndExpression andExp : BooleanType boolType
from {
	G |- andExp.left : boolType
	G |- andExp.right : boolType
}

rule ArithmeticSigned
	G |- ArithmeticSigned signed : IntType intType
from {
	G |- signed.exp : intType
}






/*
 * rule invocations
 */
checkrule CheckExpression for
    Expression expr
from {
    empty |- expr : var Type type
}


