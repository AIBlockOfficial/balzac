import it.unica.tcs.bitcoinTM.AfterTimeLock
import it.unica.tcs.bitcoinTM.AndExpression
import it.unica.tcs.bitcoinTM.ArithmeticSigned
import it.unica.tcs.bitcoinTM.BasicType
import it.unica.tcs.bitcoinTM.Between
import it.unica.tcs.bitcoinTM.BitcoinTMFactory
import it.unica.tcs.bitcoinTM.BooleanLiteral
import it.unica.tcs.bitcoinTM.BooleanNegation
import it.unica.tcs.bitcoinTM.BooleanType
import it.unica.tcs.bitcoinTM.Comparison
import it.unica.tcs.bitcoinTM.Equals
import it.unica.tcs.bitcoinTM.Expression
import it.unica.tcs.bitcoinTM.Hash
import it.unica.tcs.bitcoinTM.IfThenElse
import it.unica.tcs.bitcoinTM.IntType
import it.unica.tcs.bitcoinTM.Max
import it.unica.tcs.bitcoinTM.Min
import it.unica.tcs.bitcoinTM.Minus
import it.unica.tcs.bitcoinTM.NumberLiteral
import it.unica.tcs.bitcoinTM.OrExpression
import it.unica.tcs.bitcoinTM.Parameter
import it.unica.tcs.bitcoinTM.Plus
import it.unica.tcs.bitcoinTM.Script
import it.unica.tcs.bitcoinTM.Signature
import it.unica.tcs.bitcoinTM.SignatureType
import it.unica.tcs.bitcoinTM.Size
import it.unica.tcs.bitcoinTM.StringLiteral
import it.unica.tcs.bitcoinTM.StringType
import it.unica.tcs.bitcoinTM.Type
import it.unica.tcs.bitcoinTM.TypeVariable
import it.unica.tcs.bitcoinTM.VariableReference
import it.unica.tcs.bitcoinTM.Versig
import it.unica.tcs.bitcoinTM.WitnessScript
import it.unica.tcs.validation.AbstractBitcoinTMValidator
import org.eclipse.emf.ecore.util.EcoreUtil

system it.unica.tcs.xsemantics.BitcoinTMTypeSystem

validatorExtends AbstractBitcoinTMValidator

inject LambdaUtils lambdaUtils


auxiliary {
	notoccur(Type type, Type other)
        error stringRep(type) + " occurs in " + stringRep(other)
        
    typesubstitution(TypeSubstitutions substitutions, Type original) : Type
    
    unify(TypeSubstitutions substitutions, Type left, Type right) : Type
        error "Cannot unify " + stringRep(left) + " with " + stringRep(right)
        
}

judgments {

	scriptType |~ Script s
		error "Cannot type " + stringRep(s)
		source s
	
	witscriptType ||~ WitnessScript s
		error "Cannot type " + stringRep(s)
		source s
	

	type |- TypeSubstitutions substitutions |> Expression exp : output Type
		error "Cannot type " + stringRep(exp)
		source exp
		
	vartype ||- Parameter p : output Type
		error "Cannot type " + stringRep(p)
		source p
//		
//	validate |= EObject obj
//		error "cannot type " + stringRep(obj)
//		source obj
	
//	interpret |- Expression expression ~> output Object
}

/*
 * auxiliary functions
 */

auxiliary notoccur(Type type, Type other) { true }

auxiliary notoccur(TypeVariable variable, TypeVariable other) {
    variable.value != other.value
}

auxiliary typesubstitution(TypeSubstitutions substitutions, Type type) {
    type
}

auxiliary typesubstitution(TypeSubstitutions substitutions, TypeVariable variable)
{
    var mapped = substitutions.mapped(variable.value)
    if (mapped !== null) {
        val result = EcoreUtil::copy(mapped)
        typesubstitution(substitutions, result) // recursive
    } else
        variable
}

auxiliary unify(TypeSubstitutions substitutions, Type t1, Type t2) {
    // if we get here we cannot unify the two types
    fail
	null
} 

auxiliary unify(TypeSubstitutions substitutions, StringType t1, StringType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, BooleanType t1, BooleanType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, SignatureType t1, SignatureType t2) {
    EcoreUtil::copy(t1)
}

auxiliary unify(TypeSubstitutions substitutions, IntType t1, IntType t2) {
    EcoreUtil::copy(t1)
}


auxiliary unify(TypeSubstitutions substitutions, TypeVariable typeVar, BasicType basicType) {
    substitutions.add(typeVar.value, basicType)
    EcoreUtil.copy(basicType)
}

auxiliary unify(TypeSubstitutions substitutions, BasicType basicType, TypeVariable typeVar) {
    unify(substitutions, typeVar, basicType)
}

auxiliary unify(TypeSubstitutions substitutions, TypeVariable left, TypeVariable right) {
    // unify both variables with a fresh new variable
    val fresh = lambdaUtils.createFreshTypeVariable
    substitutions.add(left.value, fresh)
    substitutions.add(right.value, fresh)
    fresh
}



/*
 * expressions
 */

rule Script
	G |~ Script script
from {
	for (p : script.params) {
		G ||- p : var Type paramType
		G.add(p, paramType)
	}
	G |- new TypeSubstitutions() |> script.exp : var Type texp
}

rule WitnessScript
	G ||~ WitnessScript witness
from {
	
	var substitutions = new TypeSubstitutions()

	for (var i=0; i<witness.exps.size; i++) {
		var exp = witness.exps.get(i)
		G |- substitutions |> exp : var BasicType texp
	}
}

rule Parameter
	G ||- Parameter p : Type type
from {
	{
		p.paramType !== null
		type = EcoreUtil.copy(p.paramType)
	}
	or {
		type = lambdaUtils.createFreshTypeVariable
	}
}

axiom NumeralLiteral
	G |- TypeSubstitutions substitutions |> NumberLiteral num : BitcoinTMFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- TypeSubstitutions substitutions |> BooleanLiteral bool : BitcoinTMFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- TypeSubstitutions substitutions |> StringLiteral str : BitcoinTMFactory::eINSTANCE.createStringType

axiom Signature
	G |- TypeSubstitutions substitutions |> Signature s : BitcoinTMFactory::eINSTANCE.createSignatureType

rule VariableReference
	G |- TypeSubstitutions substitutions |> VariableReference varRef : Type type
from {
	type = typesubstitution(substitutions, EcoreUtil.copy(env(G, varRef.ref, Type)))
	varRef.ref.paramType = type	// set the param type, useful just for the ui
}


rule Minus
	G |- TypeSubstitutions substitutions |> Minus minus : IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> minus.left: var Type leftType
	G |- substitutions |> minus.right: var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// the terms type must be unifiable with int type
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Plus
    G |- TypeSubstitutions substitutions |> Plus plus : Type type
from {
    G |- substitutions |> plus.left : var Type leftType
    G |- substitutions |> plus.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
    {
    	type = BitcoinTMFactory::eINSTANCE.createStringType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
	}
    or
    {
       	type = BitcoinTMFactory::eINSTANCE.createIntType
		// the terms type must be unifiable with int type
		unify(substitutions, leftType, type)
		unify(substitutions, rightType, type)
    }
}

rule Comparison
	G |- TypeSubstitutions substitutions |> Comparison comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, t)
	unify(substitutions, rightType, t)
}

rule Equals
	G |- TypeSubstitutions substitutions |> Equals comparison : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	G |- substitutions |> comparison.left : var Type leftType
	G |- substitutions |> comparison.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	// equals between elements of the same type
	unify(substitutions, leftType, rightType)
}

rule BooleanNegation
	G |- TypeSubstitutions substitutions |> BooleanNegation negation : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> negation.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, boolType)
}

rule Or
	G |- TypeSubstitutions substitutions |> OrExpression orExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> orExp.left : var Type leftType
	G |- substitutions |> orExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule And
	G |- TypeSubstitutions substitutions |> AndExpression andExp : BooleanType boolType
from {
	boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> andExp.left : var Type leftType
	G |- substitutions |> andExp.right : var Type rightType
	
	leftType = typesubstitution(substitutions, leftType)
	rightType = typesubstitution(substitutions, rightType)
	
	unify(substitutions, leftType, boolType)
	unify(substitutions, rightType, boolType)
}

rule ArithmeticSigned
	G |- TypeSubstitutions substitutions |> ArithmeticSigned signed : IntType intType
from {
	intType = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> signed.exp : var Type t
	
	t = typesubstitution(substitutions, t)
	
	unify(substitutions, t, intType)
}

rule IfThenElse
	G |- TypeSubstitutions substitutions |> IfThenElse stmt : Type type
from {
	var boolType = BitcoinTMFactory::eINSTANCE.createBooleanType
	G |- substitutions |> stmt.^if: var Type tIf
	G |- substitutions |> stmt.then: var Type tThen
	
	tIf = typesubstitution(substitutions, tIf)
	tThen = typesubstitution(substitutions, tThen)
	
	unify(substitutions, tIf, boolType)

	if (stmt.^else!==null) {
		G |- substitutions |> stmt.^else: var Type tElse
		tElse = typesubstitution(substitutions, tElse)
		unify(substitutions, tThen, tElse)
	}
	
	type=tThen
}

rule VerSig
	G |- TypeSubstitutions substitutions |> Versig versig : BitcoinTMFactory::eINSTANCE.createBooleanType
from {
	var sigType = BitcoinTMFactory::eINSTANCE.createSignatureType
	
	for (s : versig.signatures) {
		G |- substitutions |> s : var Type t
		t = typesubstitution(substitutions, t)
		unify(substitutions, t, sigType)
	}	
}

rule Hash
	G |- TypeSubstitutions substitutions |> Hash hash: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> hash.value: var Type t
	t = typesubstitution(substitutions, t)
}

rule Min
	G |- TypeSubstitutions substitutions |> Min min: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> min.left: var Type tleft
	G |- substitutions |> min.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Max
	G |- TypeSubstitutions substitutions |> Max max: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> max.left: var Type tleft
	G |- substitutions |> max.right: var Type tright
	
	tleft = typesubstitution(substitutions, tleft)
	tright = typesubstitution(substitutions, tright)
	
	unify(substitutions, tleft, t)
	unify(substitutions, tright, t)
}

rule Between
	G |- TypeSubstitutions substitutions |> Between between: IntType t
from {
	t = BitcoinTMFactory::eINSTANCE.createIntType
	G |- substitutions |> between.value: var Type tValue
	G |- substitutions |> between.left: var Type tLeft
	G |- substitutions |> between.right: var Type tRight
	
	tValue = typesubstitution(substitutions, tValue)
	tLeft = typesubstitution(substitutions, tLeft)
	tRight = typesubstitution(substitutions, tRight)
	
	unify(substitutions, tValue, t)
	unify(substitutions, tLeft, t)
	unify(substitutions, tRight, t)
}

rule Size
	G |- TypeSubstitutions substitutions |> Size size: BitcoinTMFactory::eINSTANCE.createIntType
from {
	G |- substitutions |> size.value: var Type t
	
	t = typesubstitution(substitutions, t)
}

rule AfterTimeLock
	G |- TypeSubstitutions substitutions |> AfterTimeLock after: Type texpr
from {
	var intType = BitcoinTMFactory::eINSTANCE.createIntType
	
	G |- substitutions |> after.time: var Type tvalue
	G |- substitutions |> after.continuation: texpr
	
	tvalue = typesubstitution(substitutions, tvalue)
	texpr = typesubstitution(substitutions, texpr)
	
	unify(substitutions, tvalue, intType)
}


/*
 * rule invocations
 */
checkrule CheckScript for
    Script script
from {
	lambdaUtils.resetCounter
    empty |~ script
}

checkrule CheckWitnessScript for
    WitnessScript script
from {
	lambdaUtils.resetCounter
    empty ||~ script
}

