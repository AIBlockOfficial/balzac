/*
 * Andrychowicz
 */
 
package it.unica.btm.time_commitment


participant Alice {
	t
	key kA = "cSthBXr8YQAexpKeh22LB9PdextVE1UJeahmyns5LzcmMDSy59L4"
	key kB = "cQtkW1zgFCckRYvJ2Nm8rryV825GyDJ51qoJCw72rhHG4YmGfYgZ"
	key kC = "cRLgSnk3t7DhitfxkS21dWrBEiF8mFm2fSwEskLhk9shV4Jkuz66"
}

transaction T_commitA { 
	input = _
	output = 10 BTC: 
		fun(sigma1, sigma2, x:string).
			hash160(x) == hash160:9bc4f920cd2154cad285426b3fa1b18e823423d4 && versig(kA; sigma1)
			||
			versig(kA, kB; sigma1, sigma2)
}

transaction T_commitB { 
	input = _
	output = 10 BTC: 
		fun(sigma1, sigma2, x:string).
			hash160(x) == hash160:b9871797591d23183cd726d7d7d8ef4c31befbb9 && versig(kB; sigma1)
			||
			versig(kA, kB; sigma1, sigma2)
}

transaction T_openA { 
	input = T_commitA: sig kA sig kA "secretA"
	output = 10 BTC - 10: fun(sigma) .versig(kA; sigma)
}

transaction T_openB {
	input = T_commitB: sig kB sig kB "secretB"
	output = 10 BTC - 10: fun(sigma) . versig(kA; sigma)
}



transaction T_payDepositA {
    input = T_commitA: sig kA sig kB ""
 	output = 10 BTC - 10: fun(sigma) . versig(kA; sigma)
	after block 45
}

transaction T_payDepositB {
    input = T_commitB: sig kA sig kB ""
 	output = 10 BTC - 10: fun(sigma) . versig(kB; sigma)
	after block 45
}

transaction T_compute {
    input = _
	output =
		2 BTC: fun(sigma1, sigma2, xA:string, xB:string) . 
			hash160(xA) == hash160:9bc4f920cd2154cad285426b3fa1b18e823423d4 &&
			hash160(xB) == hash160:b9871797591d23183cd726d7d7d8ef4c31befbb9 &&
			(size(xA) == 128 || size(xA) == 127) && 
			(size(xB) == 128 || size(xB) == 127) &&
			if size(xA) == size(xB) 
			then versig(kA; sigma1) 
			else versig(kB; sigma2)
 
} 


//participant PA = "gianni"
//participant PB = "raga"
//
//
//contract CA  {
//	put T_commitA . send to PB: sig kA  . put T_openA
//}
//
//contract CB {
//	when T_commitA: 
//		receive from PA: sig kA . 
//		when after block 45 : 
//			put T_payDepositA
//}